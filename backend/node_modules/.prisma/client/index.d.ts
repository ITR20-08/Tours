
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model benefit
 */

export type benefit = {
  id: number
  description: string
}

/**
 * Model category
 */

export type category = {
  id: number
  description: string
}

/**
 * Model location
 */

export type location = {
  id: number
  country: string
  city: string
}

/**
 * Model picture
 */

export type picture = {
  id: number
  Tour: string
  picture: Buffer
}

/**
 * Model reservation
 */

export type reservation = {
  id: number
  Tour: string
  quantity: number
  User: string
}

/**
 * Model review
 */

export type review = {
  id: number
  description: string
  calification: number
  Tour: string
  User: string
}

/**
 * Model tour
 */

export type tour = {
  id: string
  name: string
  description: string
  duration: number
  start_date: Date
  price_for_person: Prisma.Decimal
  max_capacity: number
  calification: number
  Category: number
  Location: number
}

/**
 * Model tour_benefit
 */

export type tour_benefit = {
  Tour: string
  Benefit: number
}

/**
 * Model user
 */

export type user = {
  name: string
  last_name: string
  email: string
  country: string
  birth_date: Date
  password: string
  type: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Benefits
 * const benefits = await prisma.benefit.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Benefits
   * const benefits = await prisma.benefit.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.benefit`: Exposes CRUD operations for the **benefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Benefits
    * const benefits = await prisma.benefit.findMany()
    * ```
    */
  get benefit(): Prisma.benefitDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<GlobalReject>;

  /**
   * `prisma.picture`: Exposes CRUD operations for the **picture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pictures
    * const pictures = await prisma.picture.findMany()
    * ```
    */
  get picture(): Prisma.pictureDelegate<GlobalReject>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.reservationDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<GlobalReject>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.tourDelegate<GlobalReject>;

  /**
   * `prisma.tour_benefit`: Exposes CRUD operations for the **tour_benefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tour_benefits
    * const tour_benefits = await prisma.tour_benefit.findMany()
    * ```
    */
  get tour_benefit(): Prisma.tour_benefitDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.19.0
   * Query Engine version: c1455d0b443d66b0d9db9bcb1bb9ee0d5bbc511d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    benefit: 'benefit',
    category: 'category',
    location: 'location',
    picture: 'picture',
    reservation: 'reservation',
    review: 'review',
    tour: 'tour',
    tour_benefit: 'tour_benefit',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model benefit
   */


  export type AggregateBenefit = {
    count: BenefitCountAggregateOutputType | null
    avg: BenefitAvgAggregateOutputType | null
    sum: BenefitSumAggregateOutputType | null
    min: BenefitMinAggregateOutputType | null
    max: BenefitMaxAggregateOutputType | null
  }

  export type BenefitAvgAggregateOutputType = {
    id: number
  }

  export type BenefitSumAggregateOutputType = {
    id: number
  }

  export type BenefitMinAggregateOutputType = {
    id: number
    description: string | null
  }

  export type BenefitMaxAggregateOutputType = {
    id: number
    description: string | null
  }

  export type BenefitCountAggregateOutputType = {
    id: number
    description: number | null
    _all: number
  }


  export type BenefitAvgAggregateInputType = {
    id?: true
  }

  export type BenefitSumAggregateInputType = {
    id?: true
  }

  export type BenefitMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type BenefitMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type BenefitCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type BenefitAggregateArgs = {
    /**
     * Filter which benefit to aggregate.
    **/
    where?: benefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
    **/
    orderBy?: Enumerable<benefitOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: benefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned benefits
    **/
    count?: true | BenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: BenefitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: BenefitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: BenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: BenefitMaxAggregateInputType
  }

  export type GetBenefitAggregateType<T extends BenefitAggregateArgs> = {
    [P in keyof T & keyof AggregateBenefit]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefit[P]>
      : GetScalarType<T[P], AggregateBenefit[P]>
  }



  export type benefitSelect = {
    id?: boolean
    description?: boolean
    tours?: boolean | tour_benefitFindManyArgs
  }

  export type benefitInclude = {
    tours?: boolean | tour_benefitFindManyArgs
  }

  export type benefitGetPayload<
    S extends boolean | null | undefined | benefitArgs,
    U = keyof S
      > = S extends true
        ? benefit
    : S extends undefined
    ? never
    : S extends benefitArgs | benefitFindManyArgs
    ?'include' extends U
    ? benefit  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tours'
        ? Array < tour_benefitGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof benefit ?benefit [P]
  : 
          P extends 'tours'
        ? Array < tour_benefitGetPayload<S['select'][P]>>  : never
  } 
    : benefit
  : benefit


  type benefitCountArgs = Merge<
    Omit<benefitFindManyArgs, 'select' | 'include'> & {
      select?: BenefitCountAggregateInputType | true
    }
  >

  export interface benefitDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Benefit that matches the filter.
     * @param {benefitFindUniqueArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends benefitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, benefitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'benefit'> extends True ? CheckSelect<T, Prisma__benefitClient<benefit>, Prisma__benefitClient<benefitGetPayload<T>>> : CheckSelect<T, Prisma__benefitClient<benefit | null >, Prisma__benefitClient<benefitGetPayload<T> | null >>

    /**
     * Find the first Benefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitFindFirstArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends benefitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, benefitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'benefit'> extends True ? CheckSelect<T, Prisma__benefitClient<benefit>, Prisma__benefitClient<benefitGetPayload<T>>> : CheckSelect<T, Prisma__benefitClient<benefit | null >, Prisma__benefitClient<benefitGetPayload<T> | null >>

    /**
     * Find zero or more Benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Benefits
     * const benefits = await prisma.benefit.findMany()
     * 
     * // Get first 10 Benefits
     * const benefits = await prisma.benefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benefitWithIdOnly = await prisma.benefit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends benefitFindManyArgs>(
      args?: SelectSubset<T, benefitFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<benefit>>, PrismaPromise<Array<benefitGetPayload<T>>>>

    /**
     * Create a Benefit.
     * @param {benefitCreateArgs} args - Arguments to create a Benefit.
     * @example
     * // Create one Benefit
     * const Benefit = await prisma.benefit.create({
     *   data: {
     *     // ... data to create a Benefit
     *   }
     * })
     * 
    **/
    create<T extends benefitCreateArgs>(
      args: SelectSubset<T, benefitCreateArgs>
    ): CheckSelect<T, Prisma__benefitClient<benefit>, Prisma__benefitClient<benefitGetPayload<T>>>

    /**
     * Delete a Benefit.
     * @param {benefitDeleteArgs} args - Arguments to delete one Benefit.
     * @example
     * // Delete one Benefit
     * const Benefit = await prisma.benefit.delete({
     *   where: {
     *     // ... filter to delete one Benefit
     *   }
     * })
     * 
    **/
    delete<T extends benefitDeleteArgs>(
      args: SelectSubset<T, benefitDeleteArgs>
    ): CheckSelect<T, Prisma__benefitClient<benefit>, Prisma__benefitClient<benefitGetPayload<T>>>

    /**
     * Update one Benefit.
     * @param {benefitUpdateArgs} args - Arguments to update one Benefit.
     * @example
     * // Update one Benefit
     * const benefit = await prisma.benefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends benefitUpdateArgs>(
      args: SelectSubset<T, benefitUpdateArgs>
    ): CheckSelect<T, Prisma__benefitClient<benefit>, Prisma__benefitClient<benefitGetPayload<T>>>

    /**
     * Delete zero or more Benefits.
     * @param {benefitDeleteManyArgs} args - Arguments to filter Benefits to delete.
     * @example
     * // Delete a few Benefits
     * const { count } = await prisma.benefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends benefitDeleteManyArgs>(
      args?: SelectSubset<T, benefitDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Benefits
     * const benefit = await prisma.benefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends benefitUpdateManyArgs>(
      args: SelectSubset<T, benefitUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Benefit.
     * @param {benefitUpsertArgs} args - Arguments to update or create a Benefit.
     * @example
     * // Update or create a Benefit
     * const benefit = await prisma.benefit.upsert({
     *   create: {
     *     // ... data to create a Benefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Benefit we want to update
     *   }
     * })
    **/
    upsert<T extends benefitUpsertArgs>(
      args: SelectSubset<T, benefitUpsertArgs>
    ): CheckSelect<T, Prisma__benefitClient<benefit>, Prisma__benefitClient<benefitGetPayload<T>>>

    /**
     * Count the number of Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {benefitCountArgs} args - Arguments to filter Benefits to count.
     * @example
     * // Count the number of Benefits
     * const count = await prisma.benefit.count({
     *   where: {
     *     // ... the filter for the Benefits we want to count
     *   }
     * })
    **/
    count<T extends benefitCountArgs>(
      args?: Subset<T, benefitCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Benefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefitAggregateArgs>(args: Subset<T, BenefitAggregateArgs>): PrismaPromise<GetBenefitAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for benefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__benefitClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tours<T extends tour_benefitFindManyArgs = {}>(args?: Subset<T, tour_benefitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<tour_benefit>>, PrismaPromise<Array<tour_benefitGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * benefit findUnique
   */
  export type benefitFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * Throw an Error if a benefit can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which benefit to fetch.
    **/
    where: benefitWhereUniqueInput
  }


  /**
   * benefit findFirst
   */
  export type benefitFindFirstArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * Throw an Error if a benefit can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which benefit to fetch.
    **/
    where?: benefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
    **/
    orderBy?: Enumerable<benefitOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for benefits.
    **/
    cursor?: benefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of benefits.
    **/
    distinct?: Enumerable<BenefitScalarFieldEnum>
  }


  /**
   * benefit findMany
   */
  export type benefitFindManyArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * Filter, which benefits to fetch.
    **/
    where?: benefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of benefits to fetch.
    **/
    orderBy?: Enumerable<benefitOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing benefits.
    **/
    cursor?: benefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` benefits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` benefits.
    **/
    skip?: number
    distinct?: Enumerable<BenefitScalarFieldEnum>
  }


  /**
   * benefit create
   */
  export type benefitCreateArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * The data needed to create a benefit.
    **/
    data: XOR<benefitCreateInput, benefitUncheckedCreateInput>
  }


  /**
   * benefit update
   */
  export type benefitUpdateArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * The data needed to update a benefit.
    **/
    data: XOR<benefitUpdateInput, benefitUncheckedUpdateInput>
    /**
     * Choose, which benefit to update.
    **/
    where: benefitWhereUniqueInput
  }


  /**
   * benefit updateMany
   */
  export type benefitUpdateManyArgs = {
    data: XOR<benefitUpdateManyMutationInput, benefitUncheckedUpdateManyInput>
    where?: benefitWhereInput
  }


  /**
   * benefit upsert
   */
  export type benefitUpsertArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * The filter to search for the benefit to update in case it exists.
    **/
    where: benefitWhereUniqueInput
    /**
     * In case the benefit found by the `where` argument doesn't exist, create a new benefit with this data.
    **/
    create: XOR<benefitCreateInput, benefitUncheckedCreateInput>
    /**
     * In case the benefit was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<benefitUpdateInput, benefitUncheckedUpdateInput>
  }


  /**
   * benefit delete
   */
  export type benefitDeleteArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
    /**
     * Filter which benefit to delete.
    **/
    where: benefitWhereUniqueInput
  }


  /**
   * benefit deleteMany
   */
  export type benefitDeleteManyArgs = {
    where?: benefitWhereInput
  }


  /**
   * benefit without action
   */
  export type benefitArgs = {
    /**
     * Select specific fields to fetch from the benefit
    **/
    select?: benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: benefitInclude | null
  }



  /**
   * Model category
   */


  export type AggregateCategory = {
    count: CategoryCountAggregateOutputType | null
    avg: CategoryAvgAggregateOutputType | null
    sum: CategorySumAggregateOutputType | null
    min: CategoryMinAggregateOutputType | null
    max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number
  }

  export type CategorySumAggregateOutputType = {
    id: number
  }

  export type CategoryMinAggregateOutputType = {
    id: number
    description: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number
    description: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    description: number | null
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which category to aggregate.
    **/
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
    **/
    orderBy?: Enumerable<categoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
    [P in keyof T & keyof AggregateCategory]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }



  export type categorySelect = {
    id?: boolean
    description?: boolean
    tour?: boolean | tourFindManyArgs
  }

  export type categoryInclude = {
    tour?: boolean | tourFindManyArgs
  }

  export type categoryGetPayload<
    S extends boolean | null | undefined | categoryArgs,
    U = keyof S
      > = S extends true
        ? category
    : S extends undefined
    ? never
    : S extends categoryArgs | categoryFindManyArgs
    ?'include' extends U
    ? category  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tour'
        ? Array < tourGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof category ?category [P]
  : 
          P extends 'tour'
        ? Array < tourGetPayload<S['select'][P]>>  : never
  } 
    : category
  : category


  type categoryCountArgs = Merge<
    Omit<categoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }
  >

  export interface categoryDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, categoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'category'> extends True ? CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>> : CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, categoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'category'> extends True ? CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>> : CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryFindManyArgs>(
      args?: SelectSubset<T, categoryFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<category>>, PrismaPromise<Array<categoryGetPayload<T>>>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends categoryCreateArgs>(
      args: SelectSubset<T, categoryCreateArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends categoryDeleteArgs>(
      args: SelectSubset<T, categoryDeleteArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryUpdateArgs>(
      args: SelectSubset<T, categoryUpdateArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryDeleteManyArgs>(
      args?: SelectSubset<T, categoryDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryUpdateManyArgs>(
      args: SelectSubset<T, categoryUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends categoryUpsertArgs>(
      args: SelectSubset<T, categoryUpsertArgs>
    ): CheckSelect<T, Prisma__categoryClient<category>, Prisma__categoryClient<categoryGetPayload<T>>>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): PrismaPromise<GetCategoryAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__categoryClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tour<T extends tourFindManyArgs = {}>(args?: Subset<T, tourFindManyArgs>): CheckSelect<T, PrismaPromise<Array<tour>>, PrismaPromise<Array<tourGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * Throw an Error if a category can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which category to fetch.
    **/
    where: categoryWhereUniqueInput
  }


  /**
   * category findFirst
   */
  export type categoryFindFirstArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * Throw an Error if a category can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which category to fetch.
    **/
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
    **/
    orderBy?: Enumerable<categoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
    **/
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
    **/
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * category findMany
   */
  export type categoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * Filter, which categories to fetch.
    **/
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
    **/
    orderBy?: Enumerable<categoryOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
    **/
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
    **/
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * category create
   */
  export type categoryCreateArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * The data needed to create a category.
    **/
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }


  /**
   * category update
   */
  export type categoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * The data needed to update a category.
    **/
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
    **/
    where: categoryWhereUniqueInput
  }


  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs = {
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    where?: categoryWhereInput
  }


  /**
   * category upsert
   */
  export type categoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * The filter to search for the category to update in case it exists.
    **/
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
    **/
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }


  /**
   * category delete
   */
  export type categoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
    /**
     * Filter which category to delete.
    **/
    where: categoryWhereUniqueInput
  }


  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs = {
    where?: categoryWhereInput
  }


  /**
   * category without action
   */
  export type categoryArgs = {
    /**
     * Select specific fields to fetch from the category
    **/
    select?: categorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: categoryInclude | null
  }



  /**
   * Model location
   */


  export type AggregateLocation = {
    count: LocationCountAggregateOutputType | null
    avg: LocationAvgAggregateOutputType | null
    sum: LocationSumAggregateOutputType | null
    min: LocationMinAggregateOutputType | null
    max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number
  }

  export type LocationSumAggregateOutputType = {
    id: number
  }

  export type LocationMinAggregateOutputType = {
    id: number
    country: string | null
    city: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number
    country: string | null
    city: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    country: number | null
    city: number | null
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    country?: true
    city?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    country?: true
    city?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    country?: true
    city?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which location to aggregate.
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
    **/
    orderBy?: Enumerable<locationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
    [P in keyof T & keyof AggregateLocation]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }



  export type locationSelect = {
    id?: boolean
    country?: boolean
    city?: boolean
    tour?: boolean | tourFindManyArgs
  }

  export type locationInclude = {
    tour?: boolean | tourFindManyArgs
  }

  export type locationGetPayload<
    S extends boolean | null | undefined | locationArgs,
    U = keyof S
      > = S extends true
        ? location
    : S extends undefined
    ? never
    : S extends locationArgs | locationFindManyArgs
    ?'include' extends U
    ? location  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tour'
        ? Array < tourGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof location ?location [P]
  : 
          P extends 'tour'
        ? Array < tourGetPayload<S['select'][P]>>  : never
  } 
    : location
  : location


  type locationCountArgs = Merge<
    Omit<locationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }
  >

  export interface locationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location'> extends True ? CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>> : CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends locationFindManyArgs>(
      args?: SelectSubset<T, locationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<location>>, PrismaPromise<Array<locationGetPayload<T>>>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends locationCreateArgs>(
      args: SelectSubset<T, locationCreateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends locationDeleteArgs>(
      args: SelectSubset<T, locationDeleteArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationUpdateArgs>(
      args: SelectSubset<T, locationUpdateArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationDeleteManyArgs>(
      args?: SelectSubset<T, locationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationUpdateManyArgs>(
      args: SelectSubset<T, locationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends locationUpsertArgs>(
      args: SelectSubset<T, locationUpsertArgs>
    ): CheckSelect<T, Prisma__locationClient<location>, Prisma__locationClient<locationGetPayload<T>>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): PrismaPromise<GetLocationAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tour<T extends tourFindManyArgs = {}>(args?: Subset<T, tourFindManyArgs>): CheckSelect<T, PrismaPromise<Array<tour>>, PrismaPromise<Array<tourGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * location findUnique
   */
  export type locationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * Throw an Error if a location can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which location to fetch.
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location findFirst
   */
  export type locationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * Throw an Error if a location can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which location to fetch.
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
    **/
    orderBy?: Enumerable<locationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
    **/
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location findMany
   */
  export type locationFindManyArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * Filter, which locations to fetch.
    **/
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
    **/
    orderBy?: Enumerable<locationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
    **/
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
    **/
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location create
   */
  export type locationCreateArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * The data needed to create a location.
    **/
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }


  /**
   * location update
   */
  export type locationUpdateArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * The data needed to update a location.
    **/
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location updateMany
   */
  export type locationUpdateManyArgs = {
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    where?: locationWhereInput
  }


  /**
   * location upsert
   */
  export type locationUpsertArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * The filter to search for the location to update in case it exists.
    **/
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
    **/
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }


  /**
   * location delete
   */
  export type locationDeleteArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
    /**
     * Filter which location to delete.
    **/
    where: locationWhereUniqueInput
  }


  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs = {
    where?: locationWhereInput
  }


  /**
   * location without action
   */
  export type locationArgs = {
    /**
     * Select specific fields to fetch from the location
    **/
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: locationInclude | null
  }



  /**
   * Model picture
   */


  export type AggregatePicture = {
    count: PictureCountAggregateOutputType | null
    avg: PictureAvgAggregateOutputType | null
    sum: PictureSumAggregateOutputType | null
    min: PictureMinAggregateOutputType | null
    max: PictureMaxAggregateOutputType | null
  }

  export type PictureAvgAggregateOutputType = {
    id: number
  }

  export type PictureSumAggregateOutputType = {
    id: number
  }

  export type PictureMinAggregateOutputType = {
    id: number
    Tour: string | null
    picture: Buffer | null
  }

  export type PictureMaxAggregateOutputType = {
    id: number
    Tour: string | null
    picture: Buffer | null
  }

  export type PictureCountAggregateOutputType = {
    id: number
    Tour: number | null
    picture: number | null
    _all: number
  }


  export type PictureAvgAggregateInputType = {
    id?: true
  }

  export type PictureSumAggregateInputType = {
    id?: true
  }

  export type PictureMinAggregateInputType = {
    id?: true
    Tour?: true
    picture?: true
  }

  export type PictureMaxAggregateInputType = {
    id?: true
    Tour?: true
    picture?: true
  }

  export type PictureCountAggregateInputType = {
    id?: true
    Tour?: true
    picture?: true
    _all?: true
  }

  export type PictureAggregateArgs = {
    /**
     * Filter which picture to aggregate.
    **/
    where?: pictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pictures to fetch.
    **/
    orderBy?: Enumerable<pictureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: pictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pictures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pictures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pictures
    **/
    count?: true | PictureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PictureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PictureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PictureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PictureMaxAggregateInputType
  }

  export type GetPictureAggregateType<T extends PictureAggregateArgs> = {
    [P in keyof T & keyof AggregatePicture]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePicture[P]>
      : GetScalarType<T[P], AggregatePicture[P]>
  }



  export type pictureSelect = {
    id?: boolean
    Tour?: boolean
    picture?: boolean
    tour?: boolean | tourArgs
  }

  export type pictureInclude = {
    tour?: boolean | tourArgs
  }

  export type pictureGetPayload<
    S extends boolean | null | undefined | pictureArgs,
    U = keyof S
      > = S extends true
        ? picture
    : S extends undefined
    ? never
    : S extends pictureArgs | pictureFindManyArgs
    ?'include' extends U
    ? picture  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tour'
        ? tourGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof picture ?picture [P]
  : 
          P extends 'tour'
        ? tourGetPayload<S['select'][P]> : never
  } 
    : picture
  : picture


  type pictureCountArgs = Merge<
    Omit<pictureFindManyArgs, 'select' | 'include'> & {
      select?: PictureCountAggregateInputType | true
    }
  >

  export interface pictureDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Picture that matches the filter.
     * @param {pictureFindUniqueArgs} args - Arguments to find a Picture
     * @example
     * // Get one Picture
     * const picture = await prisma.picture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pictureFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pictureFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'picture'> extends True ? CheckSelect<T, Prisma__pictureClient<picture>, Prisma__pictureClient<pictureGetPayload<T>>> : CheckSelect<T, Prisma__pictureClient<picture | null >, Prisma__pictureClient<pictureGetPayload<T> | null >>

    /**
     * Find the first Picture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pictureFindFirstArgs} args - Arguments to find a Picture
     * @example
     * // Get one Picture
     * const picture = await prisma.picture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pictureFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pictureFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'picture'> extends True ? CheckSelect<T, Prisma__pictureClient<picture>, Prisma__pictureClient<pictureGetPayload<T>>> : CheckSelect<T, Prisma__pictureClient<picture | null >, Prisma__pictureClient<pictureGetPayload<T> | null >>

    /**
     * Find zero or more Pictures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pictureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pictures
     * const pictures = await prisma.picture.findMany()
     * 
     * // Get first 10 Pictures
     * const pictures = await prisma.picture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pictureWithIdOnly = await prisma.picture.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pictureFindManyArgs>(
      args?: SelectSubset<T, pictureFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<picture>>, PrismaPromise<Array<pictureGetPayload<T>>>>

    /**
     * Create a Picture.
     * @param {pictureCreateArgs} args - Arguments to create a Picture.
     * @example
     * // Create one Picture
     * const Picture = await prisma.picture.create({
     *   data: {
     *     // ... data to create a Picture
     *   }
     * })
     * 
    **/
    create<T extends pictureCreateArgs>(
      args: SelectSubset<T, pictureCreateArgs>
    ): CheckSelect<T, Prisma__pictureClient<picture>, Prisma__pictureClient<pictureGetPayload<T>>>

    /**
     * Delete a Picture.
     * @param {pictureDeleteArgs} args - Arguments to delete one Picture.
     * @example
     * // Delete one Picture
     * const Picture = await prisma.picture.delete({
     *   where: {
     *     // ... filter to delete one Picture
     *   }
     * })
     * 
    **/
    delete<T extends pictureDeleteArgs>(
      args: SelectSubset<T, pictureDeleteArgs>
    ): CheckSelect<T, Prisma__pictureClient<picture>, Prisma__pictureClient<pictureGetPayload<T>>>

    /**
     * Update one Picture.
     * @param {pictureUpdateArgs} args - Arguments to update one Picture.
     * @example
     * // Update one Picture
     * const picture = await prisma.picture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pictureUpdateArgs>(
      args: SelectSubset<T, pictureUpdateArgs>
    ): CheckSelect<T, Prisma__pictureClient<picture>, Prisma__pictureClient<pictureGetPayload<T>>>

    /**
     * Delete zero or more Pictures.
     * @param {pictureDeleteManyArgs} args - Arguments to filter Pictures to delete.
     * @example
     * // Delete a few Pictures
     * const { count } = await prisma.picture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pictureDeleteManyArgs>(
      args?: SelectSubset<T, pictureDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pictureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pictures
     * const picture = await prisma.picture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pictureUpdateManyArgs>(
      args: SelectSubset<T, pictureUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Picture.
     * @param {pictureUpsertArgs} args - Arguments to update or create a Picture.
     * @example
     * // Update or create a Picture
     * const picture = await prisma.picture.upsert({
     *   create: {
     *     // ... data to create a Picture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Picture we want to update
     *   }
     * })
    **/
    upsert<T extends pictureUpsertArgs>(
      args: SelectSubset<T, pictureUpsertArgs>
    ): CheckSelect<T, Prisma__pictureClient<picture>, Prisma__pictureClient<pictureGetPayload<T>>>

    /**
     * Count the number of Pictures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pictureCountArgs} args - Arguments to filter Pictures to count.
     * @example
     * // Count the number of Pictures
     * const count = await prisma.picture.count({
     *   where: {
     *     // ... the filter for the Pictures we want to count
     *   }
     * })
    **/
    count<T extends pictureCountArgs>(
      args?: Subset<T, pictureCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PictureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Picture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PictureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PictureAggregateArgs>(args: Subset<T, PictureAggregateArgs>): PrismaPromise<GetPictureAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for picture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pictureClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tour<T extends tourArgs = {}>(args?: Subset<T, tourArgs>): CheckSelect<T, Prisma__tourClient<tour | null >, Prisma__tourClient<tourGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * picture findUnique
   */
  export type pictureFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * Throw an Error if a picture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which picture to fetch.
    **/
    where: pictureWhereUniqueInput
  }


  /**
   * picture findFirst
   */
  export type pictureFindFirstArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * Throw an Error if a picture can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which picture to fetch.
    **/
    where?: pictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pictures to fetch.
    **/
    orderBy?: Enumerable<pictureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pictures.
    **/
    cursor?: pictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pictures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pictures.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pictures.
    **/
    distinct?: Enumerable<PictureScalarFieldEnum>
  }


  /**
   * picture findMany
   */
  export type pictureFindManyArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * Filter, which pictures to fetch.
    **/
    where?: pictureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pictures to fetch.
    **/
    orderBy?: Enumerable<pictureOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pictures.
    **/
    cursor?: pictureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pictures from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pictures.
    **/
    skip?: number
    distinct?: Enumerable<PictureScalarFieldEnum>
  }


  /**
   * picture create
   */
  export type pictureCreateArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * The data needed to create a picture.
    **/
    data: XOR<pictureCreateInput, pictureUncheckedCreateInput>
  }


  /**
   * picture update
   */
  export type pictureUpdateArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * The data needed to update a picture.
    **/
    data: XOR<pictureUpdateInput, pictureUncheckedUpdateInput>
    /**
     * Choose, which picture to update.
    **/
    where: pictureWhereUniqueInput
  }


  /**
   * picture updateMany
   */
  export type pictureUpdateManyArgs = {
    data: XOR<pictureUpdateManyMutationInput, pictureUncheckedUpdateManyInput>
    where?: pictureWhereInput
  }


  /**
   * picture upsert
   */
  export type pictureUpsertArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * The filter to search for the picture to update in case it exists.
    **/
    where: pictureWhereUniqueInput
    /**
     * In case the picture found by the `where` argument doesn't exist, create a new picture with this data.
    **/
    create: XOR<pictureCreateInput, pictureUncheckedCreateInput>
    /**
     * In case the picture was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<pictureUpdateInput, pictureUncheckedUpdateInput>
  }


  /**
   * picture delete
   */
  export type pictureDeleteArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
    /**
     * Filter which picture to delete.
    **/
    where: pictureWhereUniqueInput
  }


  /**
   * picture deleteMany
   */
  export type pictureDeleteManyArgs = {
    where?: pictureWhereInput
  }


  /**
   * picture without action
   */
  export type pictureArgs = {
    /**
     * Select specific fields to fetch from the picture
    **/
    select?: pictureSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: pictureInclude | null
  }



  /**
   * Model reservation
   */


  export type AggregateReservation = {
    count: ReservationCountAggregateOutputType | null
    avg: ReservationAvgAggregateOutputType | null
    sum: ReservationSumAggregateOutputType | null
    min: ReservationMinAggregateOutputType | null
    max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    id: number
    quantity: number
  }

  export type ReservationSumAggregateOutputType = {
    id: number
    quantity: number
  }

  export type ReservationMinAggregateOutputType = {
    id: number
    Tour: string | null
    quantity: number
    User: string | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: number
    Tour: string | null
    quantity: number
    User: string | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    Tour: number | null
    quantity: number
    User: number | null
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type ReservationSumAggregateInputType = {
    id?: true
    quantity?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    Tour?: true
    quantity?: true
    User?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    Tour?: true
    quantity?: true
    User?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    Tour?: true
    quantity?: true
    User?: true
    _all?: true
  }

  export type ReservationAggregateArgs = {
    /**
     * Filter which reservation to aggregate.
    **/
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
    **/
    orderBy?: Enumerable<reservationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reservations
    **/
    count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
    [P in keyof T & keyof AggregateReservation]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }



  export type reservationSelect = {
    id?: boolean
    Tour?: boolean
    quantity?: boolean
    User?: boolean
    tour?: boolean | tourArgs
    user?: boolean | userArgs
  }

  export type reservationInclude = {
    tour?: boolean | tourArgs
    user?: boolean | userArgs
  }

  export type reservationGetPayload<
    S extends boolean | null | undefined | reservationArgs,
    U = keyof S
      > = S extends true
        ? reservation
    : S extends undefined
    ? never
    : S extends reservationArgs | reservationFindManyArgs
    ?'include' extends U
    ? reservation  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tour'
        ? tourGetPayload<S['include'][P]> :
        P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof reservation ?reservation [P]
  : 
          P extends 'tour'
        ? tourGetPayload<S['select'][P]> :
        P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : reservation
  : reservation


  type reservationCountArgs = Merge<
    Omit<reservationFindManyArgs, 'select' | 'include'> & {
      select?: ReservationCountAggregateInputType | true
    }
  >

  export interface reservationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {reservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reservationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reservationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reservation'> extends True ? CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>> : CheckSelect<T, Prisma__reservationClient<reservation | null >, Prisma__reservationClient<reservationGetPayload<T> | null >>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reservationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reservationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reservation'> extends True ? CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>> : CheckSelect<T, Prisma__reservationClient<reservation | null >, Prisma__reservationClient<reservationGetPayload<T> | null >>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reservationFindManyArgs>(
      args?: SelectSubset<T, reservationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<reservation>>, PrismaPromise<Array<reservationGetPayload<T>>>>

    /**
     * Create a Reservation.
     * @param {reservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
    **/
    create<T extends reservationCreateArgs>(
      args: SelectSubset<T, reservationCreateArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Delete a Reservation.
     * @param {reservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
    **/
    delete<T extends reservationDeleteArgs>(
      args: SelectSubset<T, reservationDeleteArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Update one Reservation.
     * @param {reservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reservationUpdateArgs>(
      args: SelectSubset<T, reservationUpdateArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Delete zero or more Reservations.
     * @param {reservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reservationDeleteManyArgs>(
      args?: SelectSubset<T, reservationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reservationUpdateManyArgs>(
      args: SelectSubset<T, reservationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {reservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
    **/
    upsert<T extends reservationUpsertArgs>(
      args: SelectSubset<T, reservationUpsertArgs>
    ): CheckSelect<T, Prisma__reservationClient<reservation>, Prisma__reservationClient<reservationGetPayload<T>>>

    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends reservationCountArgs>(
      args?: Subset<T, reservationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): PrismaPromise<GetReservationAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reservationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tour<T extends tourArgs = {}>(args?: Subset<T, tourArgs>): CheckSelect<T, Prisma__tourClient<tour | null >, Prisma__tourClient<tourGetPayload<T> | null >>;

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * reservation findUnique
   */
  export type reservationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * Throw an Error if a reservation can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which reservation to fetch.
    **/
    where: reservationWhereUniqueInput
  }


  /**
   * reservation findFirst
   */
  export type reservationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * Throw an Error if a reservation can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which reservation to fetch.
    **/
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
    **/
    orderBy?: Enumerable<reservationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reservations.
    **/
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reservations.
    **/
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * reservation findMany
   */
  export type reservationFindManyArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * Filter, which reservations to fetch.
    **/
    where?: reservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reservations to fetch.
    **/
    orderBy?: Enumerable<reservationOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reservations.
    **/
    cursor?: reservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reservations from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reservations.
    **/
    skip?: number
    distinct?: Enumerable<ReservationScalarFieldEnum>
  }


  /**
   * reservation create
   */
  export type reservationCreateArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * The data needed to create a reservation.
    **/
    data: XOR<reservationCreateInput, reservationUncheckedCreateInput>
  }


  /**
   * reservation update
   */
  export type reservationUpdateArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * The data needed to update a reservation.
    **/
    data: XOR<reservationUpdateInput, reservationUncheckedUpdateInput>
    /**
     * Choose, which reservation to update.
    **/
    where: reservationWhereUniqueInput
  }


  /**
   * reservation updateMany
   */
  export type reservationUpdateManyArgs = {
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyInput>
    where?: reservationWhereInput
  }


  /**
   * reservation upsert
   */
  export type reservationUpsertArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * The filter to search for the reservation to update in case it exists.
    **/
    where: reservationWhereUniqueInput
    /**
     * In case the reservation found by the `where` argument doesn't exist, create a new reservation with this data.
    **/
    create: XOR<reservationCreateInput, reservationUncheckedCreateInput>
    /**
     * In case the reservation was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<reservationUpdateInput, reservationUncheckedUpdateInput>
  }


  /**
   * reservation delete
   */
  export type reservationDeleteArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
    /**
     * Filter which reservation to delete.
    **/
    where: reservationWhereUniqueInput
  }


  /**
   * reservation deleteMany
   */
  export type reservationDeleteManyArgs = {
    where?: reservationWhereInput
  }


  /**
   * reservation without action
   */
  export type reservationArgs = {
    /**
     * Select specific fields to fetch from the reservation
    **/
    select?: reservationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reservationInclude | null
  }



  /**
   * Model review
   */


  export type AggregateReview = {
    count: ReviewCountAggregateOutputType | null
    avg: ReviewAvgAggregateOutputType | null
    sum: ReviewSumAggregateOutputType | null
    min: ReviewMinAggregateOutputType | null
    max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number
    calification: number
  }

  export type ReviewSumAggregateOutputType = {
    id: number
    calification: number
  }

  export type ReviewMinAggregateOutputType = {
    id: number
    description: string | null
    calification: number
    Tour: string | null
    User: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number
    description: string | null
    calification: number
    Tour: string | null
    User: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    description: number | null
    calification: number
    Tour: number | null
    User: number | null
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    calification?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    calification?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    description?: true
    calification?: true
    Tour?: true
    User?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    description?: true
    calification?: true
    Tour?: true
    User?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    description?: true
    calification?: true
    Tour?: true
    User?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which review to aggregate.
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
    **/
    orderBy?: Enumerable<reviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }



  export type reviewSelect = {
    id?: boolean
    description?: boolean
    calification?: boolean
    Tour?: boolean
    User?: boolean
    tour?: boolean | tourArgs
    user?: boolean | userArgs
  }

  export type reviewInclude = {
    tour?: boolean | tourArgs
    user?: boolean | userArgs
  }

  export type reviewGetPayload<
    S extends boolean | null | undefined | reviewArgs,
    U = keyof S
      > = S extends true
        ? review
    : S extends undefined
    ? never
    : S extends reviewArgs | reviewFindManyArgs
    ?'include' extends U
    ? review  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tour'
        ? tourGetPayload<S['include'][P]> :
        P extends 'user'
        ? userGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof review ?review [P]
  : 
          P extends 'tour'
        ? tourGetPayload<S['select'][P]> :
        P extends 'user'
        ? userGetPayload<S['select'][P]> : never
  } 
    : review
  : review


  type reviewCountArgs = Merge<
    Omit<reviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface reviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'review'> extends True ? CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>> : CheckSelect<T, Prisma__reviewClient<review | null >, Prisma__reviewClient<reviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reviewFindManyArgs>(
      args?: SelectSubset<T, reviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends reviewCreateArgs>(
      args: SelectSubset<T, reviewCreateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends reviewDeleteArgs>(
      args: SelectSubset<T, reviewDeleteArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reviewUpdateArgs>(
      args: SelectSubset<T, reviewUpdateArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reviewDeleteManyArgs>(
      args?: SelectSubset<T, reviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reviewUpdateManyArgs>(
      args: SelectSubset<T, reviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends reviewUpsertArgs>(
      args: SelectSubset<T, reviewUpsertArgs>
    ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tour<T extends tourArgs = {}>(args?: Subset<T, tourArgs>): CheckSelect<T, Prisma__tourClient<tour | null >, Prisma__tourClient<tourGetPayload<T> | null >>;

    user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * review findUnique
   */
  export type reviewFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * Throw an Error if a review can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which review to fetch.
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review findFirst
   */
  export type reviewFindFirstArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * Throw an Error if a review can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which review to fetch.
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
    **/
    orderBy?: Enumerable<reviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review findMany
   */
  export type reviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * Filter, which reviews to fetch.
    **/
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
    **/
    orderBy?: Enumerable<reviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
    **/
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * review create
   */
  export type reviewCreateArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * The data needed to create a review.
    **/
    data: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }


  /**
   * review update
   */
  export type reviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * The data needed to update a review.
    **/
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs = {
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    where?: reviewWhereInput
  }


  /**
   * review upsert
   */
  export type reviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * The filter to search for the review to update in case it exists.
    **/
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
    **/
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }


  /**
   * review delete
   */
  export type reviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
    /**
     * Filter which review to delete.
    **/
    where: reviewWhereUniqueInput
  }


  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs = {
    where?: reviewWhereInput
  }


  /**
   * review without action
   */
  export type reviewArgs = {
    /**
     * Select specific fields to fetch from the review
    **/
    select?: reviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: reviewInclude | null
  }



  /**
   * Model tour
   */


  export type AggregateTour = {
    count: TourCountAggregateOutputType | null
    avg: TourAvgAggregateOutputType | null
    sum: TourSumAggregateOutputType | null
    min: TourMinAggregateOutputType | null
    max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    duration: number
    price_for_person: Decimal
    max_capacity: number
    calification: number
    Category: number
    Location: number
  }

  export type TourSumAggregateOutputType = {
    duration: number
    price_for_person: Decimal
    max_capacity: number
    calification: number
    Category: number
    Location: number
  }

  export type TourMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    duration: number
    start_date: Date | null
    price_for_person: Decimal
    max_capacity: number
    calification: number
    Category: number
    Location: number
  }

  export type TourMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    duration: number
    start_date: Date | null
    price_for_person: Decimal
    max_capacity: number
    calification: number
    Category: number
    Location: number
  }

  export type TourCountAggregateOutputType = {
    id: number | null
    name: number | null
    description: number | null
    duration: number
    start_date: number | null
    price_for_person: number
    max_capacity: number
    calification: number
    Category: number
    Location: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    duration?: true
    price_for_person?: true
    max_capacity?: true
    calification?: true
    Category?: true
    Location?: true
  }

  export type TourSumAggregateInputType = {
    duration?: true
    price_for_person?: true
    max_capacity?: true
    calification?: true
    Category?: true
    Location?: true
  }

  export type TourMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    start_date?: true
    price_for_person?: true
    max_capacity?: true
    calification?: true
    Category?: true
    Location?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    start_date?: true
    price_for_person?: true
    max_capacity?: true
    calification?: true
    Category?: true
    Location?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    duration?: true
    start_date?: true
    price_for_person?: true
    max_capacity?: true
    calification?: true
    Category?: true
    Location?: true
    _all?: true
  }

  export type TourAggregateArgs = {
    /**
     * Filter which tour to aggregate.
    **/
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
    **/
    orderBy?: Enumerable<tourOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tours
    **/
    count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
    [P in keyof T & keyof AggregateTour]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }



  export type tourSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    start_date?: boolean
    price_for_person?: boolean
    max_capacity?: boolean
    calification?: boolean
    Category?: boolean
    Location?: boolean
    category?: boolean | categoryArgs
    location?: boolean | locationArgs
    picture?: boolean | pictureFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    review?: boolean | reviewFindManyArgs
    benefits?: boolean | tour_benefitFindManyArgs
  }

  export type tourInclude = {
    category?: boolean | categoryArgs
    location?: boolean | locationArgs
    picture?: boolean | pictureFindManyArgs
    reservation?: boolean | reservationFindManyArgs
    review?: boolean | reviewFindManyArgs
    benefits?: boolean | tour_benefitFindManyArgs
  }

  export type tourGetPayload<
    S extends boolean | null | undefined | tourArgs,
    U = keyof S
      > = S extends true
        ? tour
    : S extends undefined
    ? never
    : S extends tourArgs | tourFindManyArgs
    ?'include' extends U
    ? tour  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'category'
        ? categoryGetPayload<S['include'][P]> :
        P extends 'location'
        ? locationGetPayload<S['include'][P]> :
        P extends 'picture'
        ? Array < pictureGetPayload<S['include'][P]>>  :
        P extends 'reservation'
        ? Array < reservationGetPayload<S['include'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['include'][P]>>  :
        P extends 'benefits'
        ? Array < tour_benefitGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof tour ?tour [P]
  : 
          P extends 'category'
        ? categoryGetPayload<S['select'][P]> :
        P extends 'location'
        ? locationGetPayload<S['select'][P]> :
        P extends 'picture'
        ? Array < pictureGetPayload<S['select'][P]>>  :
        P extends 'reservation'
        ? Array < reservationGetPayload<S['select'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['select'][P]>>  :
        P extends 'benefits'
        ? Array < tour_benefitGetPayload<S['select'][P]>>  : never
  } 
    : tour
  : tour


  type tourCountArgs = Merge<
    Omit<tourFindManyArgs, 'select' | 'include'> & {
      select?: TourCountAggregateInputType | true
    }
  >

  export interface tourDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tour that matches the filter.
     * @param {tourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tourFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tourFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tour'> extends True ? CheckSelect<T, Prisma__tourClient<tour>, Prisma__tourClient<tourGetPayload<T>>> : CheckSelect<T, Prisma__tourClient<tour | null >, Prisma__tourClient<tourGetPayload<T> | null >>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tourFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tourFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tour'> extends True ? CheckSelect<T, Prisma__tourClient<tour>, Prisma__tourClient<tourGetPayload<T>>> : CheckSelect<T, Prisma__tourClient<tour | null >, Prisma__tourClient<tourGetPayload<T> | null >>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tourFindManyArgs>(
      args?: SelectSubset<T, tourFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<tour>>, PrismaPromise<Array<tourGetPayload<T>>>>

    /**
     * Create a Tour.
     * @param {tourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
    **/
    create<T extends tourCreateArgs>(
      args: SelectSubset<T, tourCreateArgs>
    ): CheckSelect<T, Prisma__tourClient<tour>, Prisma__tourClient<tourGetPayload<T>>>

    /**
     * Delete a Tour.
     * @param {tourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
    **/
    delete<T extends tourDeleteArgs>(
      args: SelectSubset<T, tourDeleteArgs>
    ): CheckSelect<T, Prisma__tourClient<tour>, Prisma__tourClient<tourGetPayload<T>>>

    /**
     * Update one Tour.
     * @param {tourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tourUpdateArgs>(
      args: SelectSubset<T, tourUpdateArgs>
    ): CheckSelect<T, Prisma__tourClient<tour>, Prisma__tourClient<tourGetPayload<T>>>

    /**
     * Delete zero or more Tours.
     * @param {tourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tourDeleteManyArgs>(
      args?: SelectSubset<T, tourDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tourUpdateManyArgs>(
      args: SelectSubset<T, tourUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour.
     * @param {tourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
    **/
    upsert<T extends tourUpsertArgs>(
      args: SelectSubset<T, tourUpsertArgs>
    ): CheckSelect<T, Prisma__tourClient<tour>, Prisma__tourClient<tourGetPayload<T>>>

    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends tourCountArgs>(
      args?: Subset<T, tourCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): PrismaPromise<GetTourAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tourClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    category<T extends categoryArgs = {}>(args?: Subset<T, categoryArgs>): CheckSelect<T, Prisma__categoryClient<category | null >, Prisma__categoryClient<categoryGetPayload<T> | null >>;

    location<T extends locationArgs = {}>(args?: Subset<T, locationArgs>): CheckSelect<T, Prisma__locationClient<location | null >, Prisma__locationClient<locationGetPayload<T> | null >>;

    picture<T extends pictureFindManyArgs = {}>(args?: Subset<T, pictureFindManyArgs>): CheckSelect<T, PrismaPromise<Array<picture>>, PrismaPromise<Array<pictureGetPayload<T>>>>;

    reservation<T extends reservationFindManyArgs = {}>(args?: Subset<T, reservationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reservation>>, PrismaPromise<Array<reservationGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    benefits<T extends tour_benefitFindManyArgs = {}>(args?: Subset<T, tour_benefitFindManyArgs>): CheckSelect<T, PrismaPromise<Array<tour_benefit>>, PrismaPromise<Array<tour_benefitGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * tour findUnique
   */
  export type tourFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * Throw an Error if a tour can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which tour to fetch.
    **/
    where: tourWhereUniqueInput
  }


  /**
   * tour findFirst
   */
  export type tourFindFirstArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * Throw an Error if a tour can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which tour to fetch.
    **/
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
    **/
    orderBy?: Enumerable<tourOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tours.
    **/
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tours.
    **/
    distinct?: Enumerable<TourScalarFieldEnum>
  }


  /**
   * tour findMany
   */
  export type tourFindManyArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * Filter, which tours to fetch.
    **/
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
    **/
    orderBy?: Enumerable<tourOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tours.
    **/
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
    **/
    skip?: number
    distinct?: Enumerable<TourScalarFieldEnum>
  }


  /**
   * tour create
   */
  export type tourCreateArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * The data needed to create a tour.
    **/
    data: XOR<tourCreateInput, tourUncheckedCreateInput>
  }


  /**
   * tour update
   */
  export type tourUpdateArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * The data needed to update a tour.
    **/
    data: XOR<tourUpdateInput, tourUncheckedUpdateInput>
    /**
     * Choose, which tour to update.
    **/
    where: tourWhereUniqueInput
  }


  /**
   * tour updateMany
   */
  export type tourUpdateManyArgs = {
    data: XOR<tourUpdateManyMutationInput, tourUncheckedUpdateManyInput>
    where?: tourWhereInput
  }


  /**
   * tour upsert
   */
  export type tourUpsertArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * The filter to search for the tour to update in case it exists.
    **/
    where: tourWhereUniqueInput
    /**
     * In case the tour found by the `where` argument doesn't exist, create a new tour with this data.
    **/
    create: XOR<tourCreateInput, tourUncheckedCreateInput>
    /**
     * In case the tour was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<tourUpdateInput, tourUncheckedUpdateInput>
  }


  /**
   * tour delete
   */
  export type tourDeleteArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
    /**
     * Filter which tour to delete.
    **/
    where: tourWhereUniqueInput
  }


  /**
   * tour deleteMany
   */
  export type tourDeleteManyArgs = {
    where?: tourWhereInput
  }


  /**
   * tour without action
   */
  export type tourArgs = {
    /**
     * Select specific fields to fetch from the tour
    **/
    select?: tourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tourInclude | null
  }



  /**
   * Model tour_benefit
   */


  export type AggregateTour_benefit = {
    count: Tour_benefitCountAggregateOutputType | null
    avg: Tour_benefitAvgAggregateOutputType | null
    sum: Tour_benefitSumAggregateOutputType | null
    min: Tour_benefitMinAggregateOutputType | null
    max: Tour_benefitMaxAggregateOutputType | null
  }

  export type Tour_benefitAvgAggregateOutputType = {
    Benefit: number
  }

  export type Tour_benefitSumAggregateOutputType = {
    Benefit: number
  }

  export type Tour_benefitMinAggregateOutputType = {
    Tour: string | null
    Benefit: number
  }

  export type Tour_benefitMaxAggregateOutputType = {
    Tour: string | null
    Benefit: number
  }

  export type Tour_benefitCountAggregateOutputType = {
    Tour: number | null
    Benefit: number
    _all: number
  }


  export type Tour_benefitAvgAggregateInputType = {
    Benefit?: true
  }

  export type Tour_benefitSumAggregateInputType = {
    Benefit?: true
  }

  export type Tour_benefitMinAggregateInputType = {
    Tour?: true
    Benefit?: true
  }

  export type Tour_benefitMaxAggregateInputType = {
    Tour?: true
    Benefit?: true
  }

  export type Tour_benefitCountAggregateInputType = {
    Tour?: true
    Benefit?: true
    _all?: true
  }

  export type Tour_benefitAggregateArgs = {
    /**
     * Filter which tour_benefit to aggregate.
    **/
    where?: tour_benefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tour_benefits to fetch.
    **/
    orderBy?: Enumerable<tour_benefitOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: tour_benefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tour_benefits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tour_benefits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tour_benefits
    **/
    count?: true | Tour_benefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Tour_benefitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Tour_benefitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Tour_benefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Tour_benefitMaxAggregateInputType
  }

  export type GetTour_benefitAggregateType<T extends Tour_benefitAggregateArgs> = {
    [P in keyof T & keyof AggregateTour_benefit]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour_benefit[P]>
      : GetScalarType<T[P], AggregateTour_benefit[P]>
  }



  export type tour_benefitSelect = {
    Tour?: boolean
    Benefit?: boolean
    benefit?: boolean | benefitArgs
    tour?: boolean | tourArgs
  }

  export type tour_benefitInclude = {
    benefit?: boolean | benefitArgs
    tour?: boolean | tourArgs
  }

  export type tour_benefitGetPayload<
    S extends boolean | null | undefined | tour_benefitArgs,
    U = keyof S
      > = S extends true
        ? tour_benefit
    : S extends undefined
    ? never
    : S extends tour_benefitArgs | tour_benefitFindManyArgs
    ?'include' extends U
    ? tour_benefit  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'benefit'
        ? benefitGetPayload<S['include'][P]> :
        P extends 'tour'
        ? tourGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof tour_benefit ?tour_benefit [P]
  : 
          P extends 'benefit'
        ? benefitGetPayload<S['select'][P]> :
        P extends 'tour'
        ? tourGetPayload<S['select'][P]> : never
  } 
    : tour_benefit
  : tour_benefit


  type tour_benefitCountArgs = Merge<
    Omit<tour_benefitFindManyArgs, 'select' | 'include'> & {
      select?: Tour_benefitCountAggregateInputType | true
    }
  >

  export interface tour_benefitDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Tour_benefit that matches the filter.
     * @param {tour_benefitFindUniqueArgs} args - Arguments to find a Tour_benefit
     * @example
     * // Get one Tour_benefit
     * const tour_benefit = await prisma.tour_benefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tour_benefitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tour_benefitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tour_benefit'> extends True ? CheckSelect<T, Prisma__tour_benefitClient<tour_benefit>, Prisma__tour_benefitClient<tour_benefitGetPayload<T>>> : CheckSelect<T, Prisma__tour_benefitClient<tour_benefit | null >, Prisma__tour_benefitClient<tour_benefitGetPayload<T> | null >>

    /**
     * Find the first Tour_benefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tour_benefitFindFirstArgs} args - Arguments to find a Tour_benefit
     * @example
     * // Get one Tour_benefit
     * const tour_benefit = await prisma.tour_benefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tour_benefitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tour_benefitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tour_benefit'> extends True ? CheckSelect<T, Prisma__tour_benefitClient<tour_benefit>, Prisma__tour_benefitClient<tour_benefitGetPayload<T>>> : CheckSelect<T, Prisma__tour_benefitClient<tour_benefit | null >, Prisma__tour_benefitClient<tour_benefitGetPayload<T> | null >>

    /**
     * Find zero or more Tour_benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tour_benefitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tour_benefits
     * const tour_benefits = await prisma.tour_benefit.findMany()
     * 
     * // Get first 10 Tour_benefits
     * const tour_benefits = await prisma.tour_benefit.findMany({ take: 10 })
     * 
     * // Only select the `Tour`
     * const tour_benefitWithTourOnly = await prisma.tour_benefit.findMany({ select: { Tour: true } })
     * 
    **/
    findMany<T extends tour_benefitFindManyArgs>(
      args?: SelectSubset<T, tour_benefitFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<tour_benefit>>, PrismaPromise<Array<tour_benefitGetPayload<T>>>>

    /**
     * Create a Tour_benefit.
     * @param {tour_benefitCreateArgs} args - Arguments to create a Tour_benefit.
     * @example
     * // Create one Tour_benefit
     * const Tour_benefit = await prisma.tour_benefit.create({
     *   data: {
     *     // ... data to create a Tour_benefit
     *   }
     * })
     * 
    **/
    create<T extends tour_benefitCreateArgs>(
      args: SelectSubset<T, tour_benefitCreateArgs>
    ): CheckSelect<T, Prisma__tour_benefitClient<tour_benefit>, Prisma__tour_benefitClient<tour_benefitGetPayload<T>>>

    /**
     * Delete a Tour_benefit.
     * @param {tour_benefitDeleteArgs} args - Arguments to delete one Tour_benefit.
     * @example
     * // Delete one Tour_benefit
     * const Tour_benefit = await prisma.tour_benefit.delete({
     *   where: {
     *     // ... filter to delete one Tour_benefit
     *   }
     * })
     * 
    **/
    delete<T extends tour_benefitDeleteArgs>(
      args: SelectSubset<T, tour_benefitDeleteArgs>
    ): CheckSelect<T, Prisma__tour_benefitClient<tour_benefit>, Prisma__tour_benefitClient<tour_benefitGetPayload<T>>>

    /**
     * Update one Tour_benefit.
     * @param {tour_benefitUpdateArgs} args - Arguments to update one Tour_benefit.
     * @example
     * // Update one Tour_benefit
     * const tour_benefit = await prisma.tour_benefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tour_benefitUpdateArgs>(
      args: SelectSubset<T, tour_benefitUpdateArgs>
    ): CheckSelect<T, Prisma__tour_benefitClient<tour_benefit>, Prisma__tour_benefitClient<tour_benefitGetPayload<T>>>

    /**
     * Delete zero or more Tour_benefits.
     * @param {tour_benefitDeleteManyArgs} args - Arguments to filter Tour_benefits to delete.
     * @example
     * // Delete a few Tour_benefits
     * const { count } = await prisma.tour_benefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tour_benefitDeleteManyArgs>(
      args?: SelectSubset<T, tour_benefitDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tour_benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tour_benefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tour_benefits
     * const tour_benefit = await prisma.tour_benefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tour_benefitUpdateManyArgs>(
      args: SelectSubset<T, tour_benefitUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour_benefit.
     * @param {tour_benefitUpsertArgs} args - Arguments to update or create a Tour_benefit.
     * @example
     * // Update or create a Tour_benefit
     * const tour_benefit = await prisma.tour_benefit.upsert({
     *   create: {
     *     // ... data to create a Tour_benefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour_benefit we want to update
     *   }
     * })
    **/
    upsert<T extends tour_benefitUpsertArgs>(
      args: SelectSubset<T, tour_benefitUpsertArgs>
    ): CheckSelect<T, Prisma__tour_benefitClient<tour_benefit>, Prisma__tour_benefitClient<tour_benefitGetPayload<T>>>

    /**
     * Count the number of Tour_benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tour_benefitCountArgs} args - Arguments to filter Tour_benefits to count.
     * @example
     * // Count the number of Tour_benefits
     * const count = await prisma.tour_benefit.count({
     *   where: {
     *     // ... the filter for the Tour_benefits we want to count
     *   }
     * })
    **/
    count<T extends tour_benefitCountArgs>(
      args?: Subset<T, tour_benefitCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tour_benefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour_benefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tour_benefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tour_benefitAggregateArgs>(args: Subset<T, Tour_benefitAggregateArgs>): PrismaPromise<GetTour_benefitAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for tour_benefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tour_benefitClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    benefit<T extends benefitArgs = {}>(args?: Subset<T, benefitArgs>): CheckSelect<T, Prisma__benefitClient<benefit | null >, Prisma__benefitClient<benefitGetPayload<T> | null >>;

    tour<T extends tourArgs = {}>(args?: Subset<T, tourArgs>): CheckSelect<T, Prisma__tourClient<tour | null >, Prisma__tourClient<tourGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * tour_benefit findUnique
   */
  export type tour_benefitFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * Throw an Error if a tour_benefit can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which tour_benefit to fetch.
    **/
    where: tour_benefitWhereUniqueInput
  }


  /**
   * tour_benefit findFirst
   */
  export type tour_benefitFindFirstArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * Throw an Error if a tour_benefit can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which tour_benefit to fetch.
    **/
    where?: tour_benefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tour_benefits to fetch.
    **/
    orderBy?: Enumerable<tour_benefitOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tour_benefits.
    **/
    cursor?: tour_benefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tour_benefits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tour_benefits.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tour_benefits.
    **/
    distinct?: Enumerable<Tour_benefitScalarFieldEnum>
  }


  /**
   * tour_benefit findMany
   */
  export type tour_benefitFindManyArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * Filter, which tour_benefits to fetch.
    **/
    where?: tour_benefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tour_benefits to fetch.
    **/
    orderBy?: Enumerable<tour_benefitOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tour_benefits.
    **/
    cursor?: tour_benefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tour_benefits from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tour_benefits.
    **/
    skip?: number
    distinct?: Enumerable<Tour_benefitScalarFieldEnum>
  }


  /**
   * tour_benefit create
   */
  export type tour_benefitCreateArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * The data needed to create a tour_benefit.
    **/
    data: XOR<tour_benefitCreateInput, tour_benefitUncheckedCreateInput>
  }


  /**
   * tour_benefit update
   */
  export type tour_benefitUpdateArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * The data needed to update a tour_benefit.
    **/
    data: XOR<tour_benefitUpdateInput, tour_benefitUncheckedUpdateInput>
    /**
     * Choose, which tour_benefit to update.
    **/
    where: tour_benefitWhereUniqueInput
  }


  /**
   * tour_benefit updateMany
   */
  export type tour_benefitUpdateManyArgs = {
    data: XOR<tour_benefitUpdateManyMutationInput, tour_benefitUncheckedUpdateManyInput>
    where?: tour_benefitWhereInput
  }


  /**
   * tour_benefit upsert
   */
  export type tour_benefitUpsertArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * The filter to search for the tour_benefit to update in case it exists.
    **/
    where: tour_benefitWhereUniqueInput
    /**
     * In case the tour_benefit found by the `where` argument doesn't exist, create a new tour_benefit with this data.
    **/
    create: XOR<tour_benefitCreateInput, tour_benefitUncheckedCreateInput>
    /**
     * In case the tour_benefit was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<tour_benefitUpdateInput, tour_benefitUncheckedUpdateInput>
  }


  /**
   * tour_benefit delete
   */
  export type tour_benefitDeleteArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
    /**
     * Filter which tour_benefit to delete.
    **/
    where: tour_benefitWhereUniqueInput
  }


  /**
   * tour_benefit deleteMany
   */
  export type tour_benefitDeleteManyArgs = {
    where?: tour_benefitWhereInput
  }


  /**
   * tour_benefit without action
   */
  export type tour_benefitArgs = {
    /**
     * Select specific fields to fetch from the tour_benefit
    **/
    select?: tour_benefitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: tour_benefitInclude | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    name: string | null
    last_name: string | null
    email: string | null
    country: string | null
    birth_date: Date | null
    password: string | null
    type: string | null
  }

  export type UserMaxAggregateOutputType = {
    name: string | null
    last_name: string | null
    email: string | null
    country: string | null
    birth_date: Date | null
    password: string | null
    type: string | null
  }

  export type UserCountAggregateOutputType = {
    name: number | null
    last_name: number | null
    email: number | null
    country: number | null
    birth_date: number | null
    password: number | null
    type: number | null
    _all: number
  }


  export type UserMinAggregateInputType = {
    name?: true
    last_name?: true
    email?: true
    country?: true
    birth_date?: true
    password?: true
    type?: true
  }

  export type UserMaxAggregateInputType = {
    name?: true
    last_name?: true
    email?: true
    country?: true
    birth_date?: true
    password?: true
    type?: true
  }

  export type UserCountAggregateInputType = {
    name?: true
    last_name?: true
    email?: true
    country?: true
    birth_date?: true
    password?: true
    type?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }



  export type userSelect = {
    name?: boolean
    last_name?: boolean
    email?: boolean
    country?: boolean
    birth_date?: boolean
    password?: boolean
    type?: boolean
    reservation?: boolean | reservationFindManyArgs
    review?: boolean | reviewFindManyArgs
  }

  export type userInclude = {
    reservation?: boolean | reservationFindManyArgs
    review?: boolean | reviewFindManyArgs
  }

  export type userGetPayload<
    S extends boolean | null | undefined | userArgs,
    U = keyof S
      > = S extends true
        ? user
    : S extends undefined
    ? never
    : S extends userArgs | userFindManyArgs
    ?'include' extends U
    ? user  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'reservation'
        ? Array < reservationGetPayload<S['include'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user ?user [P]
  : 
          P extends 'reservation'
        ? Array < reservationGetPayload<S['select'][P]>>  :
        P extends 'review'
        ? Array < reviewGetPayload<S['select'][P]>>  : never
  } 
    : user
  : user


  type userCountArgs = Merge<
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface userDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>> : CheckSelect<T, Prisma__userClient<user | null >, Prisma__userClient<userGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const userWithNameOnly = await prisma.user.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user>>, PrismaPromise<Array<userGetPayload<T>>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reservation<T extends reservationFindManyArgs = {}>(args?: Subset<T, reservationFindManyArgs>): CheckSelect<T, PrismaPromise<Array<reservation>>, PrismaPromise<Array<reservationGetPayload<T>>>>;

    review<T extends reviewFindManyArgs = {}>(args?: Subset<T, reviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<review>>, PrismaPromise<Array<reviewGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Throw an Error if a user can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user to fetch.
    **/
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Throw an Error if a user can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user to fetch.
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Filter, which users to fetch.
    **/
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<userOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
    **/
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * The data needed to create a user.
    **/
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * The data needed to update a user.
    **/
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
    **/
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * The filter to search for the user to update in case it exists.
    **/
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
    **/
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
    /**
     * Filter which user to delete.
    **/
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    where?: userWhereInput
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
    **/
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: userInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BenefitScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type BenefitScalarFieldEnum = (typeof BenefitScalarFieldEnum)[keyof typeof BenefitScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    country: 'country',
    city: 'city'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const PictureScalarFieldEnum: {
    id: 'id',
    Tour: 'Tour',
    picture: 'picture'
  };

  export type PictureScalarFieldEnum = (typeof PictureScalarFieldEnum)[keyof typeof PictureScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    Tour: 'Tour',
    quantity: 'quantity',
    User: 'User'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    description: 'description',
    calification: 'calification',
    Tour: 'Tour',
    User: 'User'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    duration: 'duration',
    start_date: 'start_date',
    price_for_person: 'price_for_person',
    max_capacity: 'max_capacity',
    calification: 'calification',
    Category: 'Category',
    Location: 'Location'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const Tour_benefitScalarFieldEnum: {
    Tour: 'Tour',
    Benefit: 'Benefit'
  };

  export type Tour_benefitScalarFieldEnum = (typeof Tour_benefitScalarFieldEnum)[keyof typeof Tour_benefitScalarFieldEnum]


  export const UserScalarFieldEnum: {
    name: 'name',
    last_name: 'last_name',
    email: 'email',
    country: 'country',
    birth_date: 'birth_date',
    password: 'password',
    type: 'type'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type benefitWhereInput = {
    AND?: Enumerable<benefitWhereInput>
    OR?: Enumerable<benefitWhereInput>
    NOT?: Enumerable<benefitWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    tours?: Tour_benefitListRelationFilter
  }

  export type benefitOrderByInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type benefitWhereUniqueInput = {
    id?: number
  }

  export type categoryWhereInput = {
    AND?: Enumerable<categoryWhereInput>
    OR?: Enumerable<categoryWhereInput>
    NOT?: Enumerable<categoryWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    tour?: TourListRelationFilter
  }

  export type categoryOrderByInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type categoryWhereUniqueInput = {
    id?: number
  }

  export type locationWhereInput = {
    AND?: Enumerable<locationWhereInput>
    OR?: Enumerable<locationWhereInput>
    NOT?: Enumerable<locationWhereInput>
    id?: IntFilter | number
    country?: StringFilter | string
    city?: StringFilter | string
    tour?: TourListRelationFilter
  }

  export type locationOrderByInput = {
    id?: SortOrder
    country?: SortOrder
    city?: SortOrder
  }

  export type locationWhereUniqueInput = {
    id?: number
  }

  export type pictureWhereInput = {
    AND?: Enumerable<pictureWhereInput>
    OR?: Enumerable<pictureWhereInput>
    NOT?: Enumerable<pictureWhereInput>
    id?: IntFilter | number
    Tour?: StringFilter | string
    picture?: BytesFilter | Buffer
    tour?: XOR<TourRelationFilter, tourWhereInput>
  }

  export type pictureOrderByInput = {
    id?: SortOrder
    Tour?: SortOrder
    picture?: SortOrder
  }

  export type pictureWhereUniqueInput = {
    id?: number
  }

  export type reservationWhereInput = {
    AND?: Enumerable<reservationWhereInput>
    OR?: Enumerable<reservationWhereInput>
    NOT?: Enumerable<reservationWhereInput>
    id?: IntFilter | number
    Tour?: StringFilter | string
    quantity?: IntFilter | number
    User?: StringFilter | string
    tour?: XOR<TourRelationFilter, tourWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type reservationOrderByInput = {
    id?: SortOrder
    Tour?: SortOrder
    quantity?: SortOrder
    User?: SortOrder
  }

  export type reservationWhereUniqueInput = {
    id?: number
  }

  export type reviewWhereInput = {
    AND?: Enumerable<reviewWhereInput>
    OR?: Enumerable<reviewWhereInput>
    NOT?: Enumerable<reviewWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    calification?: IntFilter | number
    Tour?: StringFilter | string
    User?: StringFilter | string
    tour?: XOR<TourRelationFilter, tourWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type reviewOrderByInput = {
    id?: SortOrder
    description?: SortOrder
    calification?: SortOrder
    Tour?: SortOrder
    User?: SortOrder
  }

  export type reviewWhereUniqueInput = {
    id?: number
  }

  export type tourWhereInput = {
    AND?: Enumerable<tourWhereInput>
    OR?: Enumerable<tourWhereInput>
    NOT?: Enumerable<tourWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    duration?: IntFilter | number
    start_date?: DateTimeFilter | Date | string
    price_for_person?: DecimalFilter | Decimal | number | string
    max_capacity?: IntFilter | number
    calification?: IntFilter | number
    Category?: IntFilter | number
    Location?: IntFilter | number
    category?: XOR<CategoryRelationFilter, categoryWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
    picture?: PictureListRelationFilter
    reservation?: ReservationListRelationFilter
    review?: ReviewListRelationFilter
    benefits?: Tour_benefitListRelationFilter
  }

  export type tourOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    start_date?: SortOrder
    price_for_person?: SortOrder
    max_capacity?: SortOrder
    calification?: SortOrder
    Category?: SortOrder
    Location?: SortOrder
  }

  export type tourWhereUniqueInput = {
    id?: string
  }

  export type tour_benefitWhereInput = {
    AND?: Enumerable<tour_benefitWhereInput>
    OR?: Enumerable<tour_benefitWhereInput>
    NOT?: Enumerable<tour_benefitWhereInput>
    Tour?: StringFilter | string
    Benefit?: IntFilter | number
    benefit?: XOR<BenefitRelationFilter, benefitWhereInput>
    tour?: XOR<TourRelationFilter, tourWhereInput>
  }

  export type tour_benefitOrderByInput = {
    Tour?: SortOrder
    Benefit?: SortOrder
  }

  export type tour_benefitWhereUniqueInput = {
    Tour_Benefit?: tour_benefitTourBenefitCompoundUniqueInput
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    name?: StringFilter | string
    last_name?: StringFilter | string
    email?: StringFilter | string
    country?: StringFilter | string
    birth_date?: DateTimeFilter | Date | string
    password?: StringFilter | string
    type?: StringFilter | string
    reservation?: ReservationListRelationFilter
    review?: ReviewListRelationFilter
  }

  export type userOrderByInput = {
    name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    country?: SortOrder
    birth_date?: SortOrder
    password?: SortOrder
    type?: SortOrder
  }

  export type userWhereUniqueInput = {
    email?: string
  }

  export type benefitCreateInput = {
    description: string
    tours?: tour_benefitCreateNestedManyWithoutBenefitInput
  }

  export type benefitUncheckedCreateInput = {
    id?: number
    description: string
    tours?: tour_benefitUncheckedCreateNestedManyWithoutBenefitInput
  }

  export type benefitUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    tours?: tour_benefitUpdateManyWithoutBenefitInput
  }

  export type benefitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    tours?: tour_benefitUncheckedUpdateManyWithoutBenefitInput
  }

  export type benefitUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type benefitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type categoryCreateInput = {
    description: string
    tour?: tourCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    description: string
    tour?: tourUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    tour?: tourUpdateManyWithoutCategoryInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    tour?: tourUncheckedUpdateManyWithoutCategoryInput
  }

  export type categoryUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type locationCreateInput = {
    country: string
    city: string
    tour?: tourCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id?: number
    country: string
    city: string
    tour?: tourUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    tour?: tourUpdateManyWithoutLocationInput
  }

  export type locationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    tour?: tourUncheckedUpdateManyWithoutLocationInput
  }

  export type locationUpdateManyMutationInput = {
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type locationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type pictureCreateInput = {
    picture: Buffer
    tour: tourCreateNestedOneWithoutPictureInput
  }

  export type pictureUncheckedCreateInput = {
    id?: number
    Tour: string
    picture: Buffer
  }

  export type pictureUpdateInput = {
    picture?: BytesFieldUpdateOperationsInput | Buffer
    tour?: tourUpdateOneRequiredWithoutPictureInput
  }

  export type pictureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    picture?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type pictureUpdateManyMutationInput = {
    picture?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type pictureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    picture?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type reservationCreateInput = {
    quantity: number
    tour: tourCreateNestedOneWithoutReservationInput
    user: userCreateNestedOneWithoutReservationInput
  }

  export type reservationUncheckedCreateInput = {
    id?: number
    Tour: string
    quantity: number
    User: string
  }

  export type reservationUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    tour?: tourUpdateOneRequiredWithoutReservationInput
    user?: userUpdateOneRequiredWithoutReservationInput
  }

  export type reservationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    User?: StringFieldUpdateOperationsInput | string
  }

  export type reservationUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type reservationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    User?: StringFieldUpdateOperationsInput | string
  }

  export type reviewCreateInput = {
    description: string
    calification: number
    tour: tourCreateNestedOneWithoutReviewInput
    user: userCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    id?: number
    description: string
    calification: number
    Tour: string
    User: string
  }

  export type reviewUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    tour?: tourUpdateOneRequiredWithoutReviewInput
    user?: userUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    User?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    User?: StringFieldUpdateOperationsInput | string
  }

  export type tourCreateInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    category: categoryCreateNestedOneWithoutTourInput
    location: locationCreateNestedOneWithoutTourInput
    picture?: pictureCreateNestedManyWithoutTourInput
    reservation?: reservationCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    benefits?: tour_benefitCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Category: number
    Location: number
    picture?: pictureUncheckedCreateNestedManyWithoutTourInput
    reservation?: reservationUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    benefits?: tour_benefitUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    category?: categoryUpdateOneRequiredWithoutTourInput
    location?: locationUpdateOneRequiredWithoutTourInput
    picture?: pictureUpdateManyWithoutTourInput
    reservation?: reservationUpdateManyWithoutTourInput
    review?: reviewUpdateManyWithoutTourInput
    benefits?: tour_benefitUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
    picture?: pictureUncheckedUpdateManyWithoutTourInput
    reservation?: reservationUncheckedUpdateManyWithoutTourInput
    review?: reviewUncheckedUpdateManyWithoutTourInput
    benefits?: tour_benefitUncheckedUpdateManyWithoutTourInput
  }

  export type tourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
  }

  export type tourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
  }

  export type tour_benefitCreateInput = {
    benefit: benefitCreateNestedOneWithoutToursInput
    tour: tourCreateNestedOneWithoutBenefitsInput
  }

  export type tour_benefitUncheckedCreateInput = {
    Tour: string
    Benefit: number
  }

  export type tour_benefitUpdateInput = {
    benefit?: benefitUpdateOneRequiredWithoutToursInput
    tour?: tourUpdateOneRequiredWithoutBenefitsInput
  }

  export type tour_benefitUncheckedUpdateInput = {
    Tour?: StringFieldUpdateOperationsInput | string
    Benefit?: IntFieldUpdateOperationsInput | number
  }

  export type tour_benefitUpdateManyMutationInput = {

  }

  export type tour_benefitUncheckedUpdateManyInput = {
    Tour?: StringFieldUpdateOperationsInput | string
    Benefit?: IntFieldUpdateOperationsInput | number
  }

  export type userCreateInput = {
    name: string
    last_name: string
    email: string
    country: string
    birth_date: Date | string
    password: string
    type: string
    reservation?: reservationCreateNestedManyWithoutUserInput
    review?: reviewCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    name: string
    last_name: string
    email: string
    country: string
    birth_date: Date | string
    password: string
    type: string
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
    review?: reviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reservation?: reservationUpdateManyWithoutUserInput
    review?: reviewUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reservation?: reservationUncheckedUpdateManyWithoutUserInput
    review?: reviewUncheckedUpdateManyWithoutUserInput
  }

  export type userUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type userUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type Tour_benefitListRelationFilter = {
    every?: tour_benefitWhereInput
    some?: tour_benefitWhereInput
    none?: tour_benefitWhereInput
  }

  export type TourListRelationFilter = {
    every?: tourWhereInput
    some?: tourWhereInput
    none?: tourWhereInput
  }

  export type BytesFilter = {
    equals?: Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type TourRelationFilter = {
    is?: tourWhereInput
    isNot?: tourWhereInput
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type CategoryRelationFilter = {
    is?: categoryWhereInput
    isNot?: categoryWhereInput
  }

  export type LocationRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type PictureListRelationFilter = {
    every?: pictureWhereInput
    some?: pictureWhereInput
    none?: pictureWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: reservationWhereInput
    some?: reservationWhereInput
    none?: reservationWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type BenefitRelationFilter = {
    is?: benefitWhereInput
    isNot?: benefitWhereInput
  }

  export type tour_benefitTourBenefitCompoundUniqueInput = {
    Tour: string
    Benefit: number
  }

  export type tour_benefitCreateNestedManyWithoutBenefitInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutBenefitInput>, Enumerable<tour_benefitUncheckedCreateWithoutBenefitInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutBenefitInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
  }

  export type tour_benefitUncheckedCreateNestedManyWithoutBenefitInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutBenefitInput>, Enumerable<tour_benefitUncheckedCreateWithoutBenefitInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutBenefitInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type tour_benefitUpdateManyWithoutBenefitInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutBenefitInput>, Enumerable<tour_benefitUncheckedCreateWithoutBenefitInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutBenefitInput>
    upsert?: Enumerable<tour_benefitUpsertWithWhereUniqueWithoutBenefitInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
    set?: Enumerable<tour_benefitWhereUniqueInput>
    disconnect?: Enumerable<tour_benefitWhereUniqueInput>
    delete?: Enumerable<tour_benefitWhereUniqueInput>
    update?: Enumerable<tour_benefitUpdateWithWhereUniqueWithoutBenefitInput>
    updateMany?: Enumerable<tour_benefitUpdateManyWithWhereWithoutBenefitInput>
    deleteMany?: Enumerable<tour_benefitScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tour_benefitUncheckedUpdateManyWithoutBenefitInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutBenefitInput>, Enumerable<tour_benefitUncheckedCreateWithoutBenefitInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutBenefitInput>
    upsert?: Enumerable<tour_benefitUpsertWithWhereUniqueWithoutBenefitInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
    set?: Enumerable<tour_benefitWhereUniqueInput>
    disconnect?: Enumerable<tour_benefitWhereUniqueInput>
    delete?: Enumerable<tour_benefitWhereUniqueInput>
    update?: Enumerable<tour_benefitUpdateWithWhereUniqueWithoutBenefitInput>
    updateMany?: Enumerable<tour_benefitUpdateManyWithWhereWithoutBenefitInput>
    deleteMany?: Enumerable<tour_benefitScalarWhereInput>
  }

  export type tourCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<tourCreateWithoutCategoryInput>, Enumerable<tourUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutCategoryInput>
    connect?: Enumerable<tourWhereUniqueInput>
  }

  export type tourUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<tourCreateWithoutCategoryInput>, Enumerable<tourUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutCategoryInput>
    connect?: Enumerable<tourWhereUniqueInput>
  }

  export type tourUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<tourCreateWithoutCategoryInput>, Enumerable<tourUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<tourUpsertWithWhereUniqueWithoutCategoryInput>
    connect?: Enumerable<tourWhereUniqueInput>
    set?: Enumerable<tourWhereUniqueInput>
    disconnect?: Enumerable<tourWhereUniqueInput>
    delete?: Enumerable<tourWhereUniqueInput>
    update?: Enumerable<tourUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<tourUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<tourScalarWhereInput>
  }

  export type tourUncheckedUpdateManyWithoutCategoryInput = {
    create?: XOR<Enumerable<tourCreateWithoutCategoryInput>, Enumerable<tourUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<tourUpsertWithWhereUniqueWithoutCategoryInput>
    connect?: Enumerable<tourWhereUniqueInput>
    set?: Enumerable<tourWhereUniqueInput>
    disconnect?: Enumerable<tourWhereUniqueInput>
    delete?: Enumerable<tourWhereUniqueInput>
    update?: Enumerable<tourUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<tourUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<tourScalarWhereInput>
  }

  export type tourCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<tourCreateWithoutLocationInput>, Enumerable<tourUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutLocationInput>
    connect?: Enumerable<tourWhereUniqueInput>
  }

  export type tourUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<tourCreateWithoutLocationInput>, Enumerable<tourUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutLocationInput>
    connect?: Enumerable<tourWhereUniqueInput>
  }

  export type tourUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<tourCreateWithoutLocationInput>, Enumerable<tourUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<tourUpsertWithWhereUniqueWithoutLocationInput>
    connect?: Enumerable<tourWhereUniqueInput>
    set?: Enumerable<tourWhereUniqueInput>
    disconnect?: Enumerable<tourWhereUniqueInput>
    delete?: Enumerable<tourWhereUniqueInput>
    update?: Enumerable<tourUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<tourUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<tourScalarWhereInput>
  }

  export type tourUncheckedUpdateManyWithoutLocationInput = {
    create?: XOR<Enumerable<tourCreateWithoutLocationInput>, Enumerable<tourUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<tourCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<tourUpsertWithWhereUniqueWithoutLocationInput>
    connect?: Enumerable<tourWhereUniqueInput>
    set?: Enumerable<tourWhereUniqueInput>
    disconnect?: Enumerable<tourWhereUniqueInput>
    delete?: Enumerable<tourWhereUniqueInput>
    update?: Enumerable<tourUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<tourUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<tourScalarWhereInput>
  }

  export type tourCreateNestedOneWithoutPictureInput = {
    create?: XOR<tourCreateWithoutPictureInput, tourUncheckedCreateWithoutPictureInput>
    connectOrCreate?: tourCreateOrConnectWithoutPictureInput
    connect?: tourWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type tourUpdateOneRequiredWithoutPictureInput = {
    create?: XOR<tourCreateWithoutPictureInput, tourUncheckedCreateWithoutPictureInput>
    connectOrCreate?: tourCreateOrConnectWithoutPictureInput
    upsert?: tourUpsertWithoutPictureInput
    connect?: tourWhereUniqueInput
    update?: XOR<tourUpdateWithoutPictureInput, tourUncheckedUpdateWithoutPictureInput>
  }

  export type tourCreateNestedOneWithoutReservationInput = {
    create?: XOR<tourCreateWithoutReservationInput, tourUncheckedCreateWithoutReservationInput>
    connectOrCreate?: tourCreateOrConnectWithoutReservationInput
    connect?: tourWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReservationInput = {
    create?: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
    connectOrCreate?: userCreateOrConnectWithoutReservationInput
    connect?: userWhereUniqueInput
  }

  export type tourUpdateOneRequiredWithoutReservationInput = {
    create?: XOR<tourCreateWithoutReservationInput, tourUncheckedCreateWithoutReservationInput>
    connectOrCreate?: tourCreateOrConnectWithoutReservationInput
    upsert?: tourUpsertWithoutReservationInput
    connect?: tourWhereUniqueInput
    update?: XOR<tourUpdateWithoutReservationInput, tourUncheckedUpdateWithoutReservationInput>
  }

  export type userUpdateOneRequiredWithoutReservationInput = {
    create?: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
    connectOrCreate?: userCreateOrConnectWithoutReservationInput
    upsert?: userUpsertWithoutReservationInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutReservationInput, userUncheckedUpdateWithoutReservationInput>
  }

  export type tourCreateNestedOneWithoutReviewInput = {
    create?: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
    connectOrCreate?: tourCreateOrConnectWithoutReviewInput
    connect?: tourWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReviewInput = {
    create?: XOR<userCreateWithoutReviewInput, userUncheckedCreateWithoutReviewInput>
    connectOrCreate?: userCreateOrConnectWithoutReviewInput
    connect?: userWhereUniqueInput
  }

  export type tourUpdateOneRequiredWithoutReviewInput = {
    create?: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
    connectOrCreate?: tourCreateOrConnectWithoutReviewInput
    upsert?: tourUpsertWithoutReviewInput
    connect?: tourWhereUniqueInput
    update?: XOR<tourUpdateWithoutReviewInput, tourUncheckedUpdateWithoutReviewInput>
  }

  export type userUpdateOneRequiredWithoutReviewInput = {
    create?: XOR<userCreateWithoutReviewInput, userUncheckedCreateWithoutReviewInput>
    connectOrCreate?: userCreateOrConnectWithoutReviewInput
    upsert?: userUpsertWithoutReviewInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutReviewInput, userUncheckedUpdateWithoutReviewInput>
  }

  export type categoryCreateNestedOneWithoutTourInput = {
    create?: XOR<categoryCreateWithoutTourInput, categoryUncheckedCreateWithoutTourInput>
    connectOrCreate?: categoryCreateOrConnectWithoutTourInput
    connect?: categoryWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutTourInput = {
    create?: XOR<locationCreateWithoutTourInput, locationUncheckedCreateWithoutTourInput>
    connectOrCreate?: locationCreateOrConnectWithoutTourInput
    connect?: locationWhereUniqueInput
  }

  export type pictureCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<pictureCreateWithoutTourInput>, Enumerable<pictureUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<pictureCreateOrConnectWithoutTourInput>
    connect?: Enumerable<pictureWhereUniqueInput>
  }

  export type reservationCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<reservationCreateWithoutTourInput>, Enumerable<reservationUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutTourInput>
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTourInput>, Enumerable<reviewUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTourInput>
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type tour_benefitCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutTourInput>, Enumerable<tour_benefitUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutTourInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
  }

  export type pictureUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<pictureCreateWithoutTourInput>, Enumerable<pictureUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<pictureCreateOrConnectWithoutTourInput>
    connect?: Enumerable<pictureWhereUniqueInput>
  }

  export type reservationUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<reservationCreateWithoutTourInput>, Enumerable<reservationUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutTourInput>
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTourInput>, Enumerable<reviewUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTourInput>
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type tour_benefitUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutTourInput>, Enumerable<tour_benefitUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutTourInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type categoryUpdateOneRequiredWithoutTourInput = {
    create?: XOR<categoryCreateWithoutTourInput, categoryUncheckedCreateWithoutTourInput>
    connectOrCreate?: categoryCreateOrConnectWithoutTourInput
    upsert?: categoryUpsertWithoutTourInput
    connect?: categoryWhereUniqueInput
    update?: XOR<categoryUpdateWithoutTourInput, categoryUncheckedUpdateWithoutTourInput>
  }

  export type locationUpdateOneRequiredWithoutTourInput = {
    create?: XOR<locationCreateWithoutTourInput, locationUncheckedCreateWithoutTourInput>
    connectOrCreate?: locationCreateOrConnectWithoutTourInput
    upsert?: locationUpsertWithoutTourInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutTourInput, locationUncheckedUpdateWithoutTourInput>
  }

  export type pictureUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<pictureCreateWithoutTourInput>, Enumerable<pictureUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<pictureCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<pictureUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<pictureWhereUniqueInput>
    set?: Enumerable<pictureWhereUniqueInput>
    disconnect?: Enumerable<pictureWhereUniqueInput>
    delete?: Enumerable<pictureWhereUniqueInput>
    update?: Enumerable<pictureUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<pictureUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<pictureScalarWhereInput>
  }

  export type reservationUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<reservationCreateWithoutTourInput>, Enumerable<reservationUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type reviewUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTourInput>, Enumerable<reviewUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type tour_benefitUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutTourInput>, Enumerable<tour_benefitUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<tour_benefitUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
    set?: Enumerable<tour_benefitWhereUniqueInput>
    disconnect?: Enumerable<tour_benefitWhereUniqueInput>
    delete?: Enumerable<tour_benefitWhereUniqueInput>
    update?: Enumerable<tour_benefitUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<tour_benefitUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<tour_benefitScalarWhereInput>
  }

  export type pictureUncheckedUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<pictureCreateWithoutTourInput>, Enumerable<pictureUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<pictureCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<pictureUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<pictureWhereUniqueInput>
    set?: Enumerable<pictureWhereUniqueInput>
    disconnect?: Enumerable<pictureWhereUniqueInput>
    delete?: Enumerable<pictureWhereUniqueInput>
    update?: Enumerable<pictureUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<pictureUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<pictureScalarWhereInput>
  }

  export type reservationUncheckedUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<reservationCreateWithoutTourInput>, Enumerable<reservationUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<reviewCreateWithoutTourInput>, Enumerable<reviewUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type tour_benefitUncheckedUpdateManyWithoutTourInput = {
    create?: XOR<Enumerable<tour_benefitCreateWithoutTourInput>, Enumerable<tour_benefitUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<tour_benefitCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<tour_benefitUpsertWithWhereUniqueWithoutTourInput>
    connect?: Enumerable<tour_benefitWhereUniqueInput>
    set?: Enumerable<tour_benefitWhereUniqueInput>
    disconnect?: Enumerable<tour_benefitWhereUniqueInput>
    delete?: Enumerable<tour_benefitWhereUniqueInput>
    update?: Enumerable<tour_benefitUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<tour_benefitUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<tour_benefitScalarWhereInput>
  }

  export type benefitCreateNestedOneWithoutToursInput = {
    create?: XOR<benefitCreateWithoutToursInput, benefitUncheckedCreateWithoutToursInput>
    connectOrCreate?: benefitCreateOrConnectWithoutToursInput
    connect?: benefitWhereUniqueInput
  }

  export type tourCreateNestedOneWithoutBenefitsInput = {
    create?: XOR<tourCreateWithoutBenefitsInput, tourUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: tourCreateOrConnectWithoutBenefitsInput
    connect?: tourWhereUniqueInput
  }

  export type benefitUpdateOneRequiredWithoutToursInput = {
    create?: XOR<benefitCreateWithoutToursInput, benefitUncheckedCreateWithoutToursInput>
    connectOrCreate?: benefitCreateOrConnectWithoutToursInput
    upsert?: benefitUpsertWithoutToursInput
    connect?: benefitWhereUniqueInput
    update?: XOR<benefitUpdateWithoutToursInput, benefitUncheckedUpdateWithoutToursInput>
  }

  export type tourUpdateOneRequiredWithoutBenefitsInput = {
    create?: XOR<tourCreateWithoutBenefitsInput, tourUncheckedCreateWithoutBenefitsInput>
    connectOrCreate?: tourCreateOrConnectWithoutBenefitsInput
    upsert?: tourUpsertWithoutBenefitsInput
    connect?: tourWhereUniqueInput
    update?: XOR<tourUpdateWithoutBenefitsInput, tourUncheckedUpdateWithoutBenefitsInput>
  }

  export type reservationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUserInput>, Enumerable<reservationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUserInput>
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type reviewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUserInput>, Enumerable<reviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUserInput>
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type reservationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUserInput>, Enumerable<reservationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUserInput>
    connect?: Enumerable<reservationWhereUniqueInput>
  }

  export type reviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUserInput>, Enumerable<reviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUserInput>
    connect?: Enumerable<reviewWhereUniqueInput>
  }

  export type reservationUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUserInput>, Enumerable<reservationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type reviewUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUserInput>, Enumerable<reviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type reservationUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<reservationCreateWithoutUserInput>, Enumerable<reservationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reservationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<reservationUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<reservationWhereUniqueInput>
    set?: Enumerable<reservationWhereUniqueInput>
    disconnect?: Enumerable<reservationWhereUniqueInput>
    delete?: Enumerable<reservationWhereUniqueInput>
    update?: Enumerable<reservationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<reservationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<reservationScalarWhereInput>
  }

  export type reviewUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<reviewCreateWithoutUserInput>, Enumerable<reviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<reviewWhereUniqueInput>
    set?: Enumerable<reviewWhereUniqueInput>
    disconnect?: Enumerable<reviewWhereUniqueInput>
    delete?: Enumerable<reviewWhereUniqueInput>
    update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<reviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<reviewScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | number | string
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalFilter | Decimal | number | string
  }

  export type tour_benefitCreateWithoutBenefitInput = {
    tour: tourCreateNestedOneWithoutBenefitsInput
  }

  export type tour_benefitUncheckedCreateWithoutBenefitInput = {
    Tour: string
  }

  export type tour_benefitCreateOrConnectWithoutBenefitInput = {
    where: tour_benefitWhereUniqueInput
    create: XOR<tour_benefitCreateWithoutBenefitInput, tour_benefitUncheckedCreateWithoutBenefitInput>
  }

  export type tour_benefitUpsertWithWhereUniqueWithoutBenefitInput = {
    where: tour_benefitWhereUniqueInput
    update: XOR<tour_benefitUpdateWithoutBenefitInput, tour_benefitUncheckedUpdateWithoutBenefitInput>
    create: XOR<tour_benefitCreateWithoutBenefitInput, tour_benefitUncheckedCreateWithoutBenefitInput>
  }

  export type tour_benefitUpdateWithWhereUniqueWithoutBenefitInput = {
    where: tour_benefitWhereUniqueInput
    data: XOR<tour_benefitUpdateWithoutBenefitInput, tour_benefitUncheckedUpdateWithoutBenefitInput>
  }

  export type tour_benefitUpdateManyWithWhereWithoutBenefitInput = {
    where: tour_benefitScalarWhereInput
    data: XOR<tour_benefitUpdateManyMutationInput, tour_benefitUncheckedUpdateManyWithoutToursInput>
  }

  export type tour_benefitScalarWhereInput = {
    AND?: Enumerable<tour_benefitScalarWhereInput>
    OR?: Enumerable<tour_benefitScalarWhereInput>
    NOT?: Enumerable<tour_benefitScalarWhereInput>
    Tour?: StringFilter | string
    Benefit?: IntFilter | number
  }

  export type tourCreateWithoutCategoryInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    location: locationCreateNestedOneWithoutTourInput
    picture?: pictureCreateNestedManyWithoutTourInput
    reservation?: reservationCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    benefits?: tour_benefitCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutCategoryInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Location: number
    picture?: pictureUncheckedCreateNestedManyWithoutTourInput
    reservation?: reservationUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    benefits?: tour_benefitUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutCategoryInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutCategoryInput, tourUncheckedCreateWithoutCategoryInput>
  }

  export type tourUpsertWithWhereUniqueWithoutCategoryInput = {
    where: tourWhereUniqueInput
    update: XOR<tourUpdateWithoutCategoryInput, tourUncheckedUpdateWithoutCategoryInput>
    create: XOR<tourCreateWithoutCategoryInput, tourUncheckedCreateWithoutCategoryInput>
  }

  export type tourUpdateWithWhereUniqueWithoutCategoryInput = {
    where: tourWhereUniqueInput
    data: XOR<tourUpdateWithoutCategoryInput, tourUncheckedUpdateWithoutCategoryInput>
  }

  export type tourUpdateManyWithWhereWithoutCategoryInput = {
    where: tourScalarWhereInput
    data: XOR<tourUpdateManyMutationInput, tourUncheckedUpdateManyWithoutTourInput>
  }

  export type tourScalarWhereInput = {
    AND?: Enumerable<tourScalarWhereInput>
    OR?: Enumerable<tourScalarWhereInput>
    NOT?: Enumerable<tourScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    duration?: IntFilter | number
    start_date?: DateTimeFilter | Date | string
    price_for_person?: DecimalFilter | Decimal | number | string
    max_capacity?: IntFilter | number
    calification?: IntFilter | number
    Category?: IntFilter | number
    Location?: IntFilter | number
  }

  export type tourCreateWithoutLocationInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    category: categoryCreateNestedOneWithoutTourInput
    picture?: pictureCreateNestedManyWithoutTourInput
    reservation?: reservationCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    benefits?: tour_benefitCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutLocationInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Category: number
    picture?: pictureUncheckedCreateNestedManyWithoutTourInput
    reservation?: reservationUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    benefits?: tour_benefitUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutLocationInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutLocationInput, tourUncheckedCreateWithoutLocationInput>
  }

  export type tourUpsertWithWhereUniqueWithoutLocationInput = {
    where: tourWhereUniqueInput
    update: XOR<tourUpdateWithoutLocationInput, tourUncheckedUpdateWithoutLocationInput>
    create: XOR<tourCreateWithoutLocationInput, tourUncheckedCreateWithoutLocationInput>
  }

  export type tourUpdateWithWhereUniqueWithoutLocationInput = {
    where: tourWhereUniqueInput
    data: XOR<tourUpdateWithoutLocationInput, tourUncheckedUpdateWithoutLocationInput>
  }

  export type tourUpdateManyWithWhereWithoutLocationInput = {
    where: tourScalarWhereInput
    data: XOR<tourUpdateManyMutationInput, tourUncheckedUpdateManyWithoutTourInput>
  }

  export type tourCreateWithoutPictureInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    category: categoryCreateNestedOneWithoutTourInput
    location: locationCreateNestedOneWithoutTourInput
    reservation?: reservationCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    benefits?: tour_benefitCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutPictureInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Category: number
    Location: number
    reservation?: reservationUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    benefits?: tour_benefitUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutPictureInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutPictureInput, tourUncheckedCreateWithoutPictureInput>
  }

  export type tourUpsertWithoutPictureInput = {
    update: XOR<tourUpdateWithoutPictureInput, tourUncheckedUpdateWithoutPictureInput>
    create: XOR<tourCreateWithoutPictureInput, tourUncheckedCreateWithoutPictureInput>
  }

  export type tourUpdateWithoutPictureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    category?: categoryUpdateOneRequiredWithoutTourInput
    location?: locationUpdateOneRequiredWithoutTourInput
    reservation?: reservationUpdateManyWithoutTourInput
    review?: reviewUpdateManyWithoutTourInput
    benefits?: tour_benefitUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateWithoutPictureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
    reservation?: reservationUncheckedUpdateManyWithoutTourInput
    review?: reviewUncheckedUpdateManyWithoutTourInput
    benefits?: tour_benefitUncheckedUpdateManyWithoutTourInput
  }

  export type tourCreateWithoutReservationInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    category: categoryCreateNestedOneWithoutTourInput
    location: locationCreateNestedOneWithoutTourInput
    picture?: pictureCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    benefits?: tour_benefitCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutReservationInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Category: number
    Location: number
    picture?: pictureUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    benefits?: tour_benefitUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutReservationInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutReservationInput, tourUncheckedCreateWithoutReservationInput>
  }

  export type userCreateWithoutReservationInput = {
    name: string
    last_name: string
    email: string
    country: string
    birth_date: Date | string
    password: string
    type: string
    review?: reviewCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReservationInput = {
    name: string
    last_name: string
    email: string
    country: string
    birth_date: Date | string
    password: string
    type: string
    review?: reviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReservationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
  }

  export type tourUpsertWithoutReservationInput = {
    update: XOR<tourUpdateWithoutReservationInput, tourUncheckedUpdateWithoutReservationInput>
    create: XOR<tourCreateWithoutReservationInput, tourUncheckedCreateWithoutReservationInput>
  }

  export type tourUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    category?: categoryUpdateOneRequiredWithoutTourInput
    location?: locationUpdateOneRequiredWithoutTourInput
    picture?: pictureUpdateManyWithoutTourInput
    review?: reviewUpdateManyWithoutTourInput
    benefits?: tour_benefitUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
    picture?: pictureUncheckedUpdateManyWithoutTourInput
    review?: reviewUncheckedUpdateManyWithoutTourInput
    benefits?: tour_benefitUncheckedUpdateManyWithoutTourInput
  }

  export type userUpsertWithoutReservationInput = {
    update: XOR<userUpdateWithoutReservationInput, userUncheckedUpdateWithoutReservationInput>
    create: XOR<userCreateWithoutReservationInput, userUncheckedCreateWithoutReservationInput>
  }

  export type userUpdateWithoutReservationInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    review?: reviewUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutReservationInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    review?: reviewUncheckedUpdateManyWithoutUserInput
  }

  export type tourCreateWithoutReviewInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    category: categoryCreateNestedOneWithoutTourInput
    location: locationCreateNestedOneWithoutTourInput
    picture?: pictureCreateNestedManyWithoutTourInput
    reservation?: reservationCreateNestedManyWithoutTourInput
    benefits?: tour_benefitCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutReviewInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Category: number
    Location: number
    picture?: pictureUncheckedCreateNestedManyWithoutTourInput
    reservation?: reservationUncheckedCreateNestedManyWithoutTourInput
    benefits?: tour_benefitUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutReviewInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
  }

  export type userCreateWithoutReviewInput = {
    name: string
    last_name: string
    email: string
    country: string
    birth_date: Date | string
    password: string
    type: string
    reservation?: reservationCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReviewInput = {
    name: string
    last_name: string
    email: string
    country: string
    birth_date: Date | string
    password: string
    type: string
    reservation?: reservationUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReviewInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReviewInput, userUncheckedCreateWithoutReviewInput>
  }

  export type tourUpsertWithoutReviewInput = {
    update: XOR<tourUpdateWithoutReviewInput, tourUncheckedUpdateWithoutReviewInput>
    create: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
  }

  export type tourUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    category?: categoryUpdateOneRequiredWithoutTourInput
    location?: locationUpdateOneRequiredWithoutTourInput
    picture?: pictureUpdateManyWithoutTourInput
    reservation?: reservationUpdateManyWithoutTourInput
    benefits?: tour_benefitUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
    picture?: pictureUncheckedUpdateManyWithoutTourInput
    reservation?: reservationUncheckedUpdateManyWithoutTourInput
    benefits?: tour_benefitUncheckedUpdateManyWithoutTourInput
  }

  export type userUpsertWithoutReviewInput = {
    update: XOR<userUpdateWithoutReviewInput, userUncheckedUpdateWithoutReviewInput>
    create: XOR<userCreateWithoutReviewInput, userUncheckedCreateWithoutReviewInput>
  }

  export type userUpdateWithoutReviewInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reservation?: reservationUpdateManyWithoutUserInput
  }

  export type userUncheckedUpdateWithoutReviewInput = {
    name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reservation?: reservationUncheckedUpdateManyWithoutUserInput
  }

  export type categoryCreateWithoutTourInput = {
    description: string
  }

  export type categoryUncheckedCreateWithoutTourInput = {
    id?: number
    description: string
  }

  export type categoryCreateOrConnectWithoutTourInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutTourInput, categoryUncheckedCreateWithoutTourInput>
  }

  export type locationCreateWithoutTourInput = {
    country: string
    city: string
  }

  export type locationUncheckedCreateWithoutTourInput = {
    id?: number
    country: string
    city: string
  }

  export type locationCreateOrConnectWithoutTourInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutTourInput, locationUncheckedCreateWithoutTourInput>
  }

  export type pictureCreateWithoutTourInput = {
    picture: Buffer
  }

  export type pictureUncheckedCreateWithoutTourInput = {
    id?: number
    picture: Buffer
  }

  export type pictureCreateOrConnectWithoutTourInput = {
    where: pictureWhereUniqueInput
    create: XOR<pictureCreateWithoutTourInput, pictureUncheckedCreateWithoutTourInput>
  }

  export type reservationCreateWithoutTourInput = {
    quantity: number
    user: userCreateNestedOneWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutTourInput = {
    id?: number
    quantity: number
    User: string
  }

  export type reservationCreateOrConnectWithoutTourInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutTourInput, reservationUncheckedCreateWithoutTourInput>
  }

  export type reviewCreateWithoutTourInput = {
    description: string
    calification: number
    user: userCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutTourInput = {
    id?: number
    description: string
    calification: number
    User: string
  }

  export type reviewCreateOrConnectWithoutTourInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput>
  }

  export type tour_benefitCreateWithoutTourInput = {
    benefit: benefitCreateNestedOneWithoutToursInput
  }

  export type tour_benefitUncheckedCreateWithoutTourInput = {
    Benefit: number
  }

  export type tour_benefitCreateOrConnectWithoutTourInput = {
    where: tour_benefitWhereUniqueInput
    create: XOR<tour_benefitCreateWithoutTourInput, tour_benefitUncheckedCreateWithoutTourInput>
  }

  export type categoryUpsertWithoutTourInput = {
    update: XOR<categoryUpdateWithoutTourInput, categoryUncheckedUpdateWithoutTourInput>
    create: XOR<categoryCreateWithoutTourInput, categoryUncheckedCreateWithoutTourInput>
  }

  export type categoryUpdateWithoutTourInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type locationUpsertWithoutTourInput = {
    update: XOR<locationUpdateWithoutTourInput, locationUncheckedUpdateWithoutTourInput>
    create: XOR<locationCreateWithoutTourInput, locationUncheckedCreateWithoutTourInput>
  }

  export type locationUpdateWithoutTourInput = {
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type locationUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    country?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
  }

  export type pictureUpsertWithWhereUniqueWithoutTourInput = {
    where: pictureWhereUniqueInput
    update: XOR<pictureUpdateWithoutTourInput, pictureUncheckedUpdateWithoutTourInput>
    create: XOR<pictureCreateWithoutTourInput, pictureUncheckedCreateWithoutTourInput>
  }

  export type pictureUpdateWithWhereUniqueWithoutTourInput = {
    where: pictureWhereUniqueInput
    data: XOR<pictureUpdateWithoutTourInput, pictureUncheckedUpdateWithoutTourInput>
  }

  export type pictureUpdateManyWithWhereWithoutTourInput = {
    where: pictureScalarWhereInput
    data: XOR<pictureUpdateManyMutationInput, pictureUncheckedUpdateManyWithoutPictureInput>
  }

  export type pictureScalarWhereInput = {
    AND?: Enumerable<pictureScalarWhereInput>
    OR?: Enumerable<pictureScalarWhereInput>
    NOT?: Enumerable<pictureScalarWhereInput>
    id?: IntFilter | number
    Tour?: StringFilter | string
    picture?: BytesFilter | Buffer
  }

  export type reservationUpsertWithWhereUniqueWithoutTourInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutTourInput, reservationUncheckedUpdateWithoutTourInput>
    create: XOR<reservationCreateWithoutTourInput, reservationUncheckedCreateWithoutTourInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutTourInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutTourInput, reservationUncheckedUpdateWithoutTourInput>
  }

  export type reservationUpdateManyWithWhereWithoutTourInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type reservationScalarWhereInput = {
    AND?: Enumerable<reservationScalarWhereInput>
    OR?: Enumerable<reservationScalarWhereInput>
    NOT?: Enumerable<reservationScalarWhereInput>
    id?: IntFilter | number
    Tour?: StringFilter | string
    quantity?: IntFilter | number
    User?: StringFilter | string
  }

  export type reviewUpsertWithWhereUniqueWithoutTourInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutTourInput, reviewUncheckedUpdateWithoutTourInput>
    create: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutTourInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutTourInput, reviewUncheckedUpdateWithoutTourInput>
  }

  export type reviewUpdateManyWithWhereWithoutTourInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type reviewScalarWhereInput = {
    AND?: Enumerable<reviewScalarWhereInput>
    OR?: Enumerable<reviewScalarWhereInput>
    NOT?: Enumerable<reviewScalarWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    calification?: IntFilter | number
    Tour?: StringFilter | string
    User?: StringFilter | string
  }

  export type tour_benefitUpsertWithWhereUniqueWithoutTourInput = {
    where: tour_benefitWhereUniqueInput
    update: XOR<tour_benefitUpdateWithoutTourInput, tour_benefitUncheckedUpdateWithoutTourInput>
    create: XOR<tour_benefitCreateWithoutTourInput, tour_benefitUncheckedCreateWithoutTourInput>
  }

  export type tour_benefitUpdateWithWhereUniqueWithoutTourInput = {
    where: tour_benefitWhereUniqueInput
    data: XOR<tour_benefitUpdateWithoutTourInput, tour_benefitUncheckedUpdateWithoutTourInput>
  }

  export type tour_benefitUpdateManyWithWhereWithoutTourInput = {
    where: tour_benefitScalarWhereInput
    data: XOR<tour_benefitUpdateManyMutationInput, tour_benefitUncheckedUpdateManyWithoutBenefitsInput>
  }

  export type benefitCreateWithoutToursInput = {
    description: string
  }

  export type benefitUncheckedCreateWithoutToursInput = {
    id?: number
    description: string
  }

  export type benefitCreateOrConnectWithoutToursInput = {
    where: benefitWhereUniqueInput
    create: XOR<benefitCreateWithoutToursInput, benefitUncheckedCreateWithoutToursInput>
  }

  export type tourCreateWithoutBenefitsInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    category: categoryCreateNestedOneWithoutTourInput
    location: locationCreateNestedOneWithoutTourInput
    picture?: pictureCreateNestedManyWithoutTourInput
    reservation?: reservationCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutBenefitsInput = {
    id: string
    name: string
    description: string
    duration: number
    start_date: Date | string
    price_for_person: Decimal | number | string
    max_capacity: number
    calification: number
    Category: number
    Location: number
    picture?: pictureUncheckedCreateNestedManyWithoutTourInput
    reservation?: reservationUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutBenefitsInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutBenefitsInput, tourUncheckedCreateWithoutBenefitsInput>
  }

  export type benefitUpsertWithoutToursInput = {
    update: XOR<benefitUpdateWithoutToursInput, benefitUncheckedUpdateWithoutToursInput>
    create: XOR<benefitCreateWithoutToursInput, benefitUncheckedCreateWithoutToursInput>
  }

  export type benefitUpdateWithoutToursInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type benefitUncheckedUpdateWithoutToursInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type tourUpsertWithoutBenefitsInput = {
    update: XOR<tourUpdateWithoutBenefitsInput, tourUncheckedUpdateWithoutBenefitsInput>
    create: XOR<tourCreateWithoutBenefitsInput, tourUncheckedCreateWithoutBenefitsInput>
  }

  export type tourUpdateWithoutBenefitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    category?: categoryUpdateOneRequiredWithoutTourInput
    location?: locationUpdateOneRequiredWithoutTourInput
    picture?: pictureUpdateManyWithoutTourInput
    reservation?: reservationUpdateManyWithoutTourInput
    review?: reviewUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateWithoutBenefitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
    picture?: pictureUncheckedUpdateManyWithoutTourInput
    reservation?: reservationUncheckedUpdateManyWithoutTourInput
    review?: reviewUncheckedUpdateManyWithoutTourInput
  }

  export type reservationCreateWithoutUserInput = {
    quantity: number
    tour: tourCreateNestedOneWithoutReservationInput
  }

  export type reservationUncheckedCreateWithoutUserInput = {
    id?: number
    Tour: string
    quantity: number
  }

  export type reservationCreateOrConnectWithoutUserInput = {
    where: reservationWhereUniqueInput
    create: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput>
  }

  export type reviewCreateWithoutUserInput = {
    description: string
    calification: number
    tour: tourCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutUserInput = {
    id?: number
    description: string
    calification: number
    Tour: string
  }

  export type reviewCreateOrConnectWithoutUserInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutUserInput, reviewUncheckedCreateWithoutUserInput>
  }

  export type reservationUpsertWithWhereUniqueWithoutUserInput = {
    where: reservationWhereUniqueInput
    update: XOR<reservationUpdateWithoutUserInput, reservationUncheckedUpdateWithoutUserInput>
    create: XOR<reservationCreateWithoutUserInput, reservationUncheckedCreateWithoutUserInput>
  }

  export type reservationUpdateWithWhereUniqueWithoutUserInput = {
    where: reservationWhereUniqueInput
    data: XOR<reservationUpdateWithoutUserInput, reservationUncheckedUpdateWithoutUserInput>
  }

  export type reservationUpdateManyWithWhereWithoutUserInput = {
    where: reservationScalarWhereInput
    data: XOR<reservationUpdateManyMutationInput, reservationUncheckedUpdateManyWithoutReservationInput>
  }

  export type reviewUpsertWithWhereUniqueWithoutUserInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutUserInput, reviewUncheckedUpdateWithoutUserInput>
    create: XOR<reviewCreateWithoutUserInput, reviewUncheckedCreateWithoutUserInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutUserInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutUserInput, reviewUncheckedUpdateWithoutUserInput>
  }

  export type reviewUpdateManyWithWhereWithoutUserInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutReviewInput>
  }

  export type tour_benefitUpdateWithoutBenefitInput = {
    tour?: tourUpdateOneRequiredWithoutBenefitsInput
  }

  export type tour_benefitUncheckedUpdateWithoutBenefitInput = {
    Tour?: StringFieldUpdateOperationsInput | string
  }

  export type tour_benefitUncheckedUpdateManyWithoutToursInput = {
    Tour?: StringFieldUpdateOperationsInput | string
  }

  export type tourUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    location?: locationUpdateOneRequiredWithoutTourInput
    picture?: pictureUpdateManyWithoutTourInput
    reservation?: reservationUpdateManyWithoutTourInput
    review?: reviewUpdateManyWithoutTourInput
    benefits?: tour_benefitUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
    picture?: pictureUncheckedUpdateManyWithoutTourInput
    reservation?: reservationUncheckedUpdateManyWithoutTourInput
    review?: reviewUncheckedUpdateManyWithoutTourInput
    benefits?: tour_benefitUncheckedUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateManyWithoutTourInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Location?: IntFieldUpdateOperationsInput | number
  }

  export type tourUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    category?: categoryUpdateOneRequiredWithoutTourInput
    picture?: pictureUpdateManyWithoutTourInput
    reservation?: reservationUpdateManyWithoutTourInput
    review?: reviewUpdateManyWithoutTourInput
    benefits?: tour_benefitUpdateManyWithoutTourInput
  }

  export type tourUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    price_for_person?: DecimalFieldUpdateOperationsInput | Decimal | number | string
    max_capacity?: IntFieldUpdateOperationsInput | number
    calification?: IntFieldUpdateOperationsInput | number
    Category?: IntFieldUpdateOperationsInput | number
    picture?: pictureUncheckedUpdateManyWithoutTourInput
    reservation?: reservationUncheckedUpdateManyWithoutTourInput
    review?: reviewUncheckedUpdateManyWithoutTourInput
    benefits?: tour_benefitUncheckedUpdateManyWithoutTourInput
  }

  export type pictureUpdateWithoutTourInput = {
    picture?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type pictureUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    picture?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type pictureUncheckedUpdateManyWithoutPictureInput = {
    id?: IntFieldUpdateOperationsInput | number
    picture?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type reservationUpdateWithoutTourInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutReservationInput
  }

  export type reservationUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    User?: StringFieldUpdateOperationsInput | string
  }

  export type reservationUncheckedUpdateManyWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    User?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUpdateWithoutTourInput = {
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    user?: userUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    User?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUncheckedUpdateManyWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    User?: StringFieldUpdateOperationsInput | string
  }

  export type tour_benefitUpdateWithoutTourInput = {
    benefit?: benefitUpdateOneRequiredWithoutToursInput
  }

  export type tour_benefitUncheckedUpdateWithoutTourInput = {
    Benefit?: IntFieldUpdateOperationsInput | number
  }

  export type tour_benefitUncheckedUpdateManyWithoutBenefitsInput = {
    Benefit?: IntFieldUpdateOperationsInput | number
  }

  export type reservationUpdateWithoutUserInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    tour?: tourUpdateOneRequiredWithoutReservationInput
  }

  export type reservationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type reviewUpdateWithoutUserInput = {
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    tour?: tourUpdateOneRequiredWithoutReviewInput
  }

  export type reviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    calification?: IntFieldUpdateOperationsInput | number
    Tour?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}